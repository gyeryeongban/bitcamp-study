# bitcamp-study

## :pushpin: Day 1

### Git Cmd

- Clone: `$ git clone`
- Pull: `$ git pull`
- Write Backup List: `$ git add .`
- Write Commit Message: `$ git commit -m " "`
- Backup to Server: `$ git push`

## :pushpin: Day 2

### Mechan Language and CPU

#### Diffrent CPU

- CPU마다 명령 규칙이 다르기 때문

### Mechan Language and OS

#### Diffrent OS

- 운영 체제마다 기계어를 배치하는 방법이 다르기 때문

### Compiler vs Interpreter

- Compiler: 명령문을 기계어로 번역
  - ex) gcc
- Interpreter: 기계어가 아니기 때문에 도우미 프로그램이 필요
  - ex) JavaScript 실행을 위해 node.js 필요

## :pushpin: Day 3

### Cmd

- Compile: `$ javac -d bin/main -encoding UTF-8 src/main/···`
- Run: `$ java -cp bin/main ···`

### Filename Extension

- .java <- Source
- .exe <- Mechan Language
- .class <- Bytecode/P-code

### Create Project

#### bin

- main <- .class file

#### src

- main <- application file
  - java <- java source
  - resources <- common file
- test <- unit test file
  - java <- java source
  - resources <- common file

## :pushpin: Day 4

### Create Project

#### Step 1

- Project
  - Source File
  - Class File

#### Step 2

- Git Repo/Project
  - bin
  - src

#### Step 3

- Git Repo
  - Root Project
    - Sub Project

#### Step 4

- Git Repo
  - Project
    - Root Project
      - Sub Project

### Build Tool

#### Ant

- Build Script File: build.xml

#### Maven

- Build Script File: pom.xml

#### Gradle

- Build Script File: build.gradle

### How to Use Gradle Build Tool

#### Gradle Basic Task

- `$ gradle init`
  - Prepare Project File
- `$ gradlew`
  - Install Gradle and Create File

#### 'Java' Gradle Plug-in

- `$ gradle compileJava`
  - Compile src/main/java
  - Copy .class File in build/classes/java/main
- `$ gradle compileTestJava`
  - Compile src/test/java
  - Copy .class File in build/classes/java/test
- `$ gradle processResources`
  - Copy src/main/resources -> build/resources/main
- `$ gradle processTestResources`
  - Copy src/test/resources -> build/resources/test
- `$ gradle clean`
  - Delete Build Folder
- `$ gradle classes`
  - Run compileJava + processResources
- `$ gradle testClasses`
  - Run classes + compileTestJava + processTestResources
- `$ gradle check`
  - Run test + unit test
- `$ gradle javadoc`
  - Create API Document.html
- `$ gradle build`
  - Run check + assemble

#### 'Application' Gradle Plug-in

- `$ gradle run`
  - Run 'Java' Plug-in classes
  - Run Class Specified in Application setting
- `$ gradle build`
  - Create Distribution File in build/distributions
  - Create Script File

## :pushpin: Day 5

### Function, Class, Package

#### Function

- 기능 단위로 문자를 묶어서 관리

#### Class

- 메서드를 역할이나 용도에 따라 분류하여 묶어서 관리

#### Package

- 클래스를 쓰임새(역할)에 따라 디렉토리로 분류하여 관리

### Javadoc

#### Create HTML Document

- Description of Code in /\*\* \*/ -> Run Javadoc -> HTML Document
- `$ javadoc -encoding utf-8 -charset utf-8 ···`

### Pulg-in

#### Create Eclipse Project

- Add 'Eclipse' Plug-in
  - [build.gradle]
  ```
  plugins {
  id 'eclipse'
  }
  ```
  - .project
    - Eclipse에게 프로젝트 이름과 유형(Java)에 대한 정보를 제공
    - 이 파일이 없으면 프로젝트 폴더로 간주 X
  - .classpath
    - 소스 폴더와 클래스 파일을 두는 폴더에 대한 정보
    - 프로젝트에서 사용하는 외부 라이브러리(.jar)의 경로 정보
    - Java 프로젝트인 경우 이 파일이 있어야 함
  - .settings
    - 기타 설정 정보를 갖고있는 파일을 보관

## :pushpin: Day 6

### literal, Variables, Array

#### Literal

- 값을 표현한 것

#### Variables

- 값을 담는 메모리

#### Array

- 여러 개의 값을 담는 메모리
- 변수 목록

### Literal

#### 정수

- 2진수: 0b
- 16진수: 0x

#### 부동 소수점

- 3.14 = 31.4e-1 = 314e-2 = 0.314e1 = 0.0314e2

#### 논리

- 소문자로 표현

#### 문자

- ' '
- 제어 문자
  - \t, \v, \n

#### 문자열

- " "

### print(), println(), printf()

#### print()

- 출력

#### println()

- 출력 + 줄바꿈
- 값 X -> 줄바꿈만 수행

#### printf(출력 형식, 값)

- 형식 지정 X -> print()와 같음
- 출력 형식
  - %s: 지정한 자리에 문자열을 삽입
  - %d: 정수 값을 10진수 문자열로 만들어 삽입
  - %x: 정수 값을 16진수 문자열로 만들어 삽입
  - %c: 정수 값을 문자로 만들어 삽입
  - %b: true/false 값을 문자열로 만들어 삽입

### 메모리와 값

#### 메모리 종류

- HDD
- RAM

#### 값

- HDD: 값을 자성 방향으로 표현하여 저장
  - N/S극 or S/N극
- RAM: 값을 전기 신호로 표현하여 저장
  - On or Off

### 값 -> 2진수

- 어떤 값이든 2진수로 표현 가능하면 HDD/RAM (=저장장치)에 값을 저장할 수 있음
- But, 규칙 필요 => 규칙이 서로 다르면 값을 주고받을 수 없기 때문

#### 정수 -> 2진수 규칙

- Sign-Magnitude (부호 절대값)
  - 부동 소수점이 가수부를 2진수로 표현할 때 사용
- 1의 보수 (음수 값을 표현할 때)
  - 크기를 넘어가면 버림
    - 1 0000 0001 => 맨 앞 1 버림
- 2의 보수 = 1의 보수 + 1 (음수 값을 표현할 때)
  - 현재 대부분의 컴퓨터가 2의 보수를 음수 표현 방법으로 사용
  - 음수를 2의 보수로 표현 => 빼기를 수행할 때 음수와 양수를 더하면 됨
- Excess-K (지정된 값을 무조건 더함)
  - 음수든 양수든 따지지 않고 무조건 K값을 더해 2진수로 표현
    - 32bit 메모리: K = 127
    - 64bit 메모리: K = 1023
  - 부동 소수점을 2진수로 표현할 때 이 규칙에 따라 지수부를 표현

### 값과 메모리

- 1byte = 8bit
- 0 ~ (2^8 - 1)
- 0 ~ 255
- -128 ~ 127

## :pushpin: Day 7

### 명령어 실행 순서

- HDD -loding-> RAM -> Cache -> CPU

### 값 -> 2진수

#### 전기 비트 (전기 신호)

- On, Off

#### 자기 비트 (자기 신호)

- N/S극, S/N극

### 정규화

- IEEE-754: 정규화 규칙을 정의한 문서
- 정해진 규칙에 따라 정리
- 가수부와 지수부를 분리
- 부동 소수점으로 표현하면 앞에 0은 생략 => 앞은 무조건 1

#### 10진수 정규화

- 변환없이 정규화

#### 2진수 정규화

- 2진수 -변환-> 정규화
- 소수점 앞/뒤로 나눠 2진수로 변환
  - 소수점 뒤 => 2진수 변환
  - 1.0이 나올 때까지 \* 2

### 문자 -> 2진수 규칙

#### Character Set (문자 집합)

- ASCII
  - 7bit
- ISO-8859-1 (ISO-latin-1~15)
  - 8bit
- EUC-KR (KSC-KR)
  - 16bit
- 조합형
  - 16bit
- MS949
  - 16bit
- Unicode
  - 16bit
- UTF-8
  - 8 ~ 32bit

### 유효 자릿수

- 유효 자릿수를 넘어가면 잘리거나 반올림 됨

#### 32bit

- Almost 7 ~ 8자리 (Default = 7)

#### 64bit

- Almost 16자리

### 폰트

- Raster 폰트 (Bitmap 폰트)
  - 크기를 늘리면 계단현상 발생
  - 폰트를 도트(점) 정보로 저장
  - 출력 속도가 빠름
  - 단순한 그림이나 복잡한 그림이 파일 크기가 같음
  - 왜? 천연색일 경우 각 점을 3바이트로 표현하기 때문
- Vector 폰트 (Truetype 폰트)
  - 크기를 늘려도 깔끔하게 출력
  - 폰트를 명령어로 저장
  - 그릴 때 마다 명령어를 실행해야 하기 때문에 출력 속도가 느림
  - 그림이 복잡할수록 명령어가 복잡하기 때문에 파일 크기가 커짐

## :pushpin: Day 8

### 문자 변수 (UCS-2 문자 코드 값 저장)

- 해당 코드의 문자를 폰트 파일에서 찾아 출력

### 자바 원시 타입 변수 (Primitive Variable)

#### 정수

- byte
  - -128 ~ 127
- short
  - -32768 ~ 32767
- int
  - 약 -21억 ~ 약 21억
- long
  - 약 -922경 ~ 약 922경

#### 부동 소수점

- float
  - 유효 자릿수 7자리 (단정도)
- double
  - 유효 자릿수 16자리 (배정도)

#### 논리

- boolean
  - int 타입의 메모리 사용 (4byte)
  - 배열은 byte 타입의 메모리 사용 (1byte)
  - 자바 언어 명세서에는 메모리의 크기가 정의되어 있지 X
  - 다만, JVM 명세서에는 int로 다룬다고 나와있음

#### 문자

- char
  - 0 ~ 65535 (유니코드)

### 레퍼런스 변수(Referece Variable)

- 자바 원시 타입의 값을 제외한 모든 값

#### String

- 자바 언어 명세서에는 메모리의 크기가 정의되어 있지 X
- 메모리 주소를 저장할 만큼 큰 크기

#### Date

- 자바 언어 명세서에는 메모리의 크기가 정의되어 있지 X
- 메모리 주소를 저장할 만큼 큰 크기

### Scanner

- 레퍼런스를 업그레이드한 것
- 시스템의 표준 입력 장치인 키보드를 Inputsteam 변수에 저장

#### Inputsteam

- 데이터가 들어오는 것

#### Outputsteam

- 데이터가 나가는 것

### l-value and r-value

- l-value은 반드시 메모리여야 함

```
20 = 30;
```

#### 리터럴

```
a = 1;
```

#### 변수

```
int a2 = a;
```

#### 표현식 (Expreeion)

- 문장을 실행 후 결과 값을 리턴하는 명령어

```
a2 = a + 11;
```

### System.in and Scanner

```
String str = keyboard.nextLine();
```

1. 키보드에서 한 줄 입력될 때까지 기다림
2. 한 줄이 입력되면 문자열을 뽑아서 리턴
3. 저장

### Reference

- 데이터가 저장된 메모리의 주소를 저장하는 메모리

#### 문자열 (주소)

- String: 문자열이 저장된 메모리의 주소를 저장
- 프로그래밍 입문 단계 => 문자열을 저장하는 메모리

#### 날짜 (주소)

- Date: 날짜 값이 저장된 메모리의 주소를 저장
- 프로그래밍 입문 단계 => 날짜를 저장하는 메모리

### JVM and Memory

1. JVM -사용할 메모리를 요구-> OS
2. OS -사용할 수 있는 메모리를 확보하여 JVM에게 할당-> JVM
3. JVM -실행하는 동안 사용-> 내부 메모리 (RAM)

### Use Scanner

- 1개의 토큰(token)을 읽을 때까지 기다림
  - 토큰: 양쪽에서 공백(White Space)으로 분리된 문자열(단어)
- 공백 앞까지만 출력
  - `next()`
  - `nextInt()`
  - `nextFloat()`
  - `nextBoolean()`

### 공백으로 인식

- Space
- Tab
- newline

### `nextXXX()`를 사용할 때 주의할 점

- 한 개의 토큰을 읽음
- 공백을 만날 때까지 읽음
- 단어 앞의 공백은 제거
- 빈 문자열을 읽으려면 `nextLine()` 사용

### How to use `nextXXX()`

- 20 aaa true 입력
- `nextInt()` -> 20 return
- `next()` -> aaa
- `nextBoolean()` -> true
- => 공백을 만나면 제거

### System.in and Scanner

- Reference로 Object에 신호를 보냄
  - ex) 리모콘(Reference)로 에어컨(Object)을 켬
  - ex) 잔디에 물 뿌리는 기계(Scanner)에 호스(System.in)를 연결해서 물을 뿌림
- Scanner 스스로 데이터를 읽을 수 없음
  - ex) 잔디에 물 뿌리는 기계가 물을 가져오진 못하는 것과 같이 물은 호스가 가져오고 기계를 호스를 연결시켜 뿌리는 역할만 함

### Scanner() 괄호 안

- 키보드 입력기
  - ex) `System.in`
- 파일
- 랜카드

## :pushpin: Day 9

### Array

- 같은 종류의 메모리를 쉽게 만드는 방법

#### 문법

```
메모리종류[] 메모리이름 = new 메모리종류[개수];
데이터타입[] 변수명 = new 데이터타입[개수];

// 정수를 담을 메모리를 5개 만들고 배열의 이름을 arr로 하자
int[] arr = new int[5];
```

#### 개수

- int 타입의 최대 값과 같음
- 2147483647개

#### 크기

- int 타입의 최대 값에서 2를 뺀 값
- Integer.MAX_VALUE - 2

#### 메모리에 접근

- 문법

```
배열변수[인덱스] = 값;
arr1[0] = 100;
```

- 배열의 인덱스는 0부터 시작
- 인덱스의 범위는 0 ~ (배열개수 - 1)

#### 선언문 분석

- `arr1`
  - 배열 메모리의 주소를 담는 변수
  - 이렇게 메모리의 주소를 보관하는 변수 => 레퍼런스
- `new int[5]`
  - 연속된 5개의 int 타입 메모리를 준비하라는 명령
  - 사용할 메모리를 확보한 후 그 메모리의 찾아 갈 수 있도록 시작 주소를 리턴
  - 이렇게 값을 저장하기 위해 확보된 메모리 => 인스턴스
- `new`
  - 사용할 메모리를 확보하는 명령
  - 리턴 값은 확보된 메모리의 시작 주소

#### 초기화

- 정수 배열 (`byte[ ]`, `short[ ]`, `int[ ]`, `long[ ]`)
  - 0
- 부동 소수점 배열 (`float[ ]`, `double[ ]`)
  - 0.0
- 논리 배열 (`boolean[ ]`)
  - false
- 문자 배열 (`char[ ]`)
  - '\u0000'
- 주소 변수 (`Object[ ]`)
  - null

### 조회용으로만 사용할 변수라면 상수로 선언

#### 상수

- 변경할 수 없는 값
- final이라는 한정자를 변수타입 앞에 붙여주면 그 변수는 변경할 수 없는 값이 됨

```
final 변수타입 변수명 = 값;
```

#### 변수명

- 전체 다 대문자
- 구분을 위해 중간에 \_를 사용

### 클래스

#### java.util.Date

- 날짜 정보를 다루는 물건을 생성

```
new java.sql.Date(밀리초)
java.sql.Date.valueOf(날짜 문자열)
java.util.Date()
```

#### java.lang.Integer

```
Integer.parseInt(Scanner.nextLine())
```

### 반복문

```
for (변수 초기화; 조건; 증감문) {}
```

#### 순서

- 변수 초기화 -> 조건 -> {} -> 증감문 -> ···
- 변수 초기화는 1번만 실행

### 연산자(operator) and 피연산자(operand)

```
i = i + 1;
```

#### 연산자(operator)

- =, +

#### 피연산자(operand)

- i, 1

### 비교

#### 변수명.equals(" ")

- 입력 받은 값이 " " 안에 들어가는 값과 같을 때
- " " 안을 비워두면 공백으로 인식

#### 변수명.equalsIgnoreCase("알파벳")

- 입력 받은 알파벳이 " " 안에 들어가는 값과 같을 때
- 대소문자를 구분하지 않음

## :pushpin: Day 10

### 배열

```
int[] arr = new int[5];
배열타입[] 레퍼런스 = 메모리준비명령 DataType[개수];
```

### 오프셋 주소 (Offset)

- Application이 할당 받은 메모리의 시작점을 0으로 하여 계산된 주소
- 어떤 기준점에서 얼마만큼 떨어졌는가

### 메모리 종류

- Primitive: Data Type 변수
- Reference: 주소 변수
  - 배열 레퍼런스, String 포함

### 상수

- 값을 오직 한 번만 저장할 수 있음
- 변수 앞에 final을 붙임
- 만약, final로 선언된 변수의 값을 두 번째로 바꾸려 한다면?
- => 컴파일 오류 발생
- 변수와 상수를 구분하기 위해서
  - 상수인 경우 이름을 보통 모두 대문자로 작성
  - 변수를 선언하는 문장에서 바로 값을 초기화시킴

### 변수의 종류

#### 인스턴스 변수(instance variable)

- new 명령을 사용하여 인스턴스를 생성할 때 준비되는 변수

```
int 변수명;
```

#### 클래스 변수(class variable = static variable)

- 클래스가 로딩될 때 준비되는 변수

```
static int 변수명;
```

#### 로컬 변수(local variable)

- 블록을 실행할 때 준비되는 변수

```
public static void main(String[] args /*로컬변수 = 파라미터*/) {
int 변수명; // 로컬 변수
}
```

### static type binding vs dynamic type binding

#### Java

- 변수의 타입이 한번 정해지면 변경되지 않음

#### JavaScript

- 변수에 값을 저장하는 순간 데이터 타입이 결정됨 (변경됨)

### 연산자

- 정수의 산술 연산의 최소 단위 = int
- 데이터 타입에 따라 사용할 수 있는 연산자가 정해져 있음
- 연산의 결과 타입은 피연산자와 같음

#### 우선 순위

1. ()
2. ++, --
3. \*, /, %
4. +, -
5. =

#### &&, || vs &, |

- &&, ||
  - 첫번째 피연산자로 결과를 예측할 수 있다면 두 번째 피연산자로 실행되지 않음
- &, |
  - 앞의 피연산자 값에 상관없이 끝까지 실행

#### 논리 연산자

- AND: &&
- OR: ||
- NOT: !
- XOR: ^
  - 배타적 비교 연산자
  - 두 개의 값이 다를 때 true
  - ^ 연산자를 정수 값에 대해 수행하면 비트 단위로 연산을 수행
- 정수 값에 사용 불가

#### 비트 연산자

- &, |, ^, ~
- 이미지 및 영상 처리에 사용
- ex) 마스킹, 오버레이 기법에 사용
- ex) 색조 변경에 사용

#### 증감 연산자

- 전위 (Prefix)

```
// 실행
System.out.println(i++);

// 연산 과정
int temp = i; <- 임시 변수를 만들어 현재 i 값을 저장
i = i + 1;
System.out.println(temp);
```

- 후위 (Postfix)

```
// 실행
System.out.println(i--);

// 연산 과정
int temp = i;
i = i - 1;
System.out.println(temp);
```

#### 할당 (배정, 대입) 연산자

- +=, -=, \*=, /=, %=
- &=, |=, ^=
- <<=, >>=, >>>=

#### 산술 연산자

- +, -, \*, /, %

### 논리 & 비트 연산자

#### &&, ||, !의 피연산자 (operand)

- 반드시 boolean이어야 함
- 계산 결과 = boolean

#### &, |, ^, ~(not)의 피연산자

- 반드시 정수여야 함
- 계산 결과 = 정수

### 비트 연산자 & 활용

- **특정 값 차단 및 특정 값만 통과**
  - 특정 비트의 값만 추출하고 싶을 때 사용
  ```
  int a = 0b1111_1001_0111_1111;
  System.out.println(Integer.toBinaryString(a & 0b0000_1111_1100_0000));
  ```
- **그림의 한 픽셀에서 특정 색 제거 및 강화**

  ```
  // 빨간색 제거
  int pixel = 0x003f4478; // 각 바이트의 값 = '00RRGGBB'로 가정
  System.out.println(pixel & 0x0000ffff);

  // 파란색 강화
  int pixel = 0x003f4478; // 각 바이트의 값 = '00RRGGBB'로 가정
  System.out.println(pixel | 0x00000057);
  ```

- **% 연산 구현**

  - % 연산 -> 여러 번
  - & 연산 -> 한 번
  - 짝수 or 홀수

  ```
  System.out.println((값 & 0x1) == 0 ? "짝수" : "홀수");
  ```

  - 2, 4, 8, 16으로 나눈 나머지

  ```
  // 2로 나눈 나머지
  System.out.println(값 % 2);
  System.out.println(값 & 0b0000_0001);
  System.out.println(값 & 1);

  // 4로 나눈 나머지
  System.out.println(값 % 4);
  System.out.println(값 & 0b11);

  // 8로 나눈 나머지
  System.out.println(값 % 8);
  System.out.println(값 & 0b111);

  // 16으로 나눈 나머지
  System.out.println(값 % 16);
  System.out.println(값 & 0b1111);
  ```

#### 결론

- 짝수 or 홀수, 2 or 2의 제곱수로 나눈 나머지
- % 대신 &를 사용하면 연산 수행이 빠름
- 어떤 값에 대해 2로 나눈 나머지 값을 구하고 싶다면,
- => & 연산자를 이용하여 그 값의 하위 1비트 값만 추출
- 어떤 값에 대해 4로 나눈 나머지 값을 구하고 싶다면,
- => & 연산자를 이용하여 그 값의 하위 2비트 값만 추출

### Pre-fix/Post-fix 증감 연산자

- 리터럴에 적용 불가

```
int a = ++100;
```

- 변수에 동시에 적용 불가

```
int a = 100;
++y++;
(++y)++;
++(y++);
```

### 파라미터(parameter)

- 메서드의 아규먼트를 받는 로컬 변수
  - ex) main()의 args 로컬 변수
- static이 붙은 블록(스태틱 메서드 = 클래스 메서드)에서는
- 그 블록 바깥 쪽에 있는 스태틱 변수(클래스 변수)를 사용 가능
- But, static 붙지 않은 인스턴스 변수는 사용할 수 없음

### 부동소수점 메모리의 값을 정수 메모리에 저장

- a. 값이 짤릴 수 있음을 알면서도 정수 메모리에 저장해야 할 때
- b. 큰 메모리의 값을 작은 메모리에 저장해야 할 때
  - 컴파일러에게 강제로 값을 넣을 것을 명시
  - => 명시적 형변환 (explicit type conversion)
  - 큰 값을 작은 메모리에 넣는 것은 아무런 의미가 없음
  - => 해서는 안됨
  - 다만, 큰 메모리의 값을 바이트 단위로 쪼개고 싶을 때 유용

#### 가능

- 정수 메모리끼리 형변환
- 부동소수점을 정수로 형변환
- 형변환 없이 정수는 부동소수점 메모리에 저장
- 숫자를 문자 코드로 형변환
- 그 외에는 형변환 불가

### 암시적 형변환

- byte, short, char -> int -> long -> float -> double

### 형변환

- 명시적 형변환이 불가능한 경우 특별한 메서드를 사용하면 가능함

```
boolean v1 = Boolean.valueOf("true");

char v2 = "가".charAt(0);

int v3 = Integer.valueOf("123");

float v4 = Float.valueOf("3.14f");
```

### 표현식(expression)

- 작업을 수행한 후 결과를 리턴하는 문장

### 문장(statement)

- 작업을 수행시키는 명령

### 문장과 표현식의 관계

- statement 중에서 결과를 리턴하는 statement를 expression이라 부름

## :pushpin: Day 11

### if ~ else 문

- else if 라는 문법은 없음

```
// 1
else {
if (age < 14)
System.out.println("어린이입니다.");
}

// 2
else
if (age < 14)
System.out.println("어린이입니다.");

// 3
else if (age < 14)
System.out.println("어린이입니다.");
```

### nextInt()

- 사용자가 콘솔 창에 입력할 수 있도록 커서를 대기시키고 싶다면 `nextInt()`를 실행
- => `nextInt()`는 사용자가 숫자를 입력하고 엔터를 칠 때까지 기다림

### if vs switch

- 복잡한 조건으로 프로그램 흐름을 제어해야 하는 상황이라면, if 문을 사용
- int나 문자열처럼 단순한 값으로 프로그램을 제어할 수 있다면, switch문을 사용하는 게 나음

### 연산자

```
// a-1
a++;
b += a;

// a-2
b += ++a;

// b-1
count++;
sum += count;

// b-2
sum += ++count;
```

### 짝수/홀수

```
// 짝수
(count & 0x01) == 0
count & 1
count & 0x01
count % 2

// 홀수
count % 2 == 1
```

### 흐름 제어문

#### switch 문법

```
switch (값) {}
```

- 값으로 가능한 데이터 타입은?
  - int 정수 (byte, short, int, char), 문자열, 특별한 상수 Enum 타입
- case 값으로 변수 사용 불가 => 리터럴만 가능
- 4바이트를 넘어가는 정수는 사용 불가
- 부동소수점 사용 불가
- boolean 값은 switch와 case에 사용 불가
- 상수를 사용하면 주석없이 바로 이해 가능
  - case 문자의 값으로 변수를 사용할 수 없음
  - 단 값이 변경되지 않는 final 변수는 사용 가능

#### switch 문법 II

- 상수를 좀 더 조직적으로 관리하는 방법
  - enum을 사용하여 상수를 정의
  - nested enum은 기본이 static
  - => static은 생략 가능

#### break와 continue 활용

- continue
  - 다음 문장을 실행하지 않고 즉시 조건 검사로 이동
  - 다음 줄로 가지 않고 변수 증가문으로 이동
- break
  - 본인이 소속된 가장 가까운 반복문을 나감
  - use) for 문, switch 문

#### 중첩된 반복문 탈출

- 라벨명: 반복문1 { 반복문2 {break 라벨명;} }
  ```
  라벨 문법:
  라벨: 문장;
  라벨: {문장1, 문장2, ...}
  ```
  - `break 라벨명;`: 라벨에 소속된 문장을 나감

#### do ~ while 반복문

- 최소 한 번은 반복
- 한 번 이상 반복: do ~ while
- 0번 이상 반복: while

```
do
문장1;
while (조건);

do {
문장1;
문장2;
문장3;
} while (조건);
```

#### for 반복문의 초기화 변수

- 변수 초기화 시키는 문장에 여러 개의 변수 선언 가능
- 변수 증가문에 여러 개의 문장 작성 가능

#### for (;;)와 배열

- 제거 가능

```
// 변수 선언 및 초기화 문장
for (; i < 0;)

// 조건문
for (;;)
```

- 배열 변수 선언과 동시에 배열 초기화를 실행할 때 new String[] 을 생략 가능

```
String[] names = {"배타미", "송가경", "차현"};
```

#### for (:)와 배열

- for (:)
  - 배열 전체를 반복하거나 컬렉션(collection) 객체 전체를 반복할 때 유용
  - 배열의 일부만 반복할 수 없음
  - 배열의 값을 다룰 때 인덱스를 사용할 필요가 없어 편리
- 문법
  ```
  for (변수 선언 : 배열, Iterable 구현체) 문장1;
  for (변수 선언 : 배열, Iterable 구현체) { 문장1; 문장2; ...}
  ```
  - 변수의 타입은 배열이나 Iterable 구현체의 항목 타입과 같아야 함
  - 반복문을 돌 때 마다 항목을 값을 꺼내 변수에 담음
  ```
  for (배열에서 꺼낸 값을 저장할 변수 선언 : 배열주소) 문장;
  ```
  - 배열의 처음부터 끝까지 값을 꺼낼 때 사용
  - 변수 선언을 바깥에 둘 수 없음

### 비트 이동 연산자

#### How to use <<

- 왼쪽으로 비트를 이동시킴
- 오른쪽 빈자리는 0으로 채움
- 왼쪽 경계를 넘어간 비트는 자름
- 왼쪽 이동
  - 값 \* (2 ^ 이동 비트)

#### How to use >>

- 왼쪽 쪽 빈자리를 원래 숫자와 같은 부호 값으로 채움
- 양수라면 0, 음수라면 1을 채움
- 오른쪽 경계를 넘어간 비트는 자름
- 오른쪽 이동
  - 값 / (2 ^ 이동 비트)

#### How to use >>>

- 오른쪽으로 비트를 이동시킴
- 왼쪽 빈자리를 음수 양수 상관없이 무조건 0으로 채움
- 오른쪽 경계를 넘어간 비트는 자름
- 오른쪽 이동

#### 비트 이동의 유효 범위

- int 타입: 0 ~ 31까지 유효
- long 타입: 0 ~ 63까지 유효

## :pushpin: Day 12

### main() 메서드의 활용

#### 문자열 입력

- int로 변환

```
Integer.parseInt()
Integer.valueOf()
```

- Date로 변환

```
Date.valueOf()
```

### 메서드 사용법: 메서드 활용

#### 장점

- 기능 단위로 관리하기 쉽게 묶음
- 재사용하기 쉬움

#### 리팩토링 (refactoring)

- 기존 코드를 유지 보수하기 쉬운 구조로 재작성하는 것

### 클래스 변수와 로컬 변수

```
// 클래스 변수
static int a = 10;

// 로컬 변수
int b = 20;
```

#### 사용 여부

- 다른 메서드의 로컬 변수는 접근 불가
- 로컬 변수는 클래스 변수 사용 가능

### prompt()

#### 파라미터 (Parameter)

- 아규먼트를 받는 변수

#### 아규먼트 (Argument)

- 프롬프트 제목
- 메서드를 실행할 때 넘겨주는 값
- 아규먼트 (= 인자값)

### prompt() 기능을 더 세분화

#### prompt()

- `promptString()`: String
- `promptInt()`: Int
- `promptDate()`: Date

## :pushpin: Day 13

### 메서드 문법

1. 명령어 블록을 실행할 때 값을 넘겨주지 않고 결과도 받지 않음

```
void 메서드명() {
문장1;
문장2;
}
```

2. 명령어 블록을 실행할 때 값을 넘겨주고 결과는 받지 않음

```
void 메서드명(변수선언1, 변수선언2, ...) {
문장1;
문장2;
}
```

3. 명령어 블록을 실행할 때 값을 넘겨주지 않고 결과는 받음

```
리턴타입 메서드명() {
문장1;
문장2;
}
```

4. 명령어 블록을 실행할 때 값을 넘겨주고 결과를 받음

```
리턴타입 메서드명(변수선언1, 변수선언2, ...) {
문장1;
문장2;
}
```

### 메서드(method) = 함수(function)

#### 메서드 정의(method definition)

```
int plus(int a, int b) {
int sum = a + b;
return sum;
}

// 의미
int: 리턴 타입
plus: 메서드명
a, b: 파라미터 (parameter)
{}: 메서드 몸체 (method body)
```

#### 메서드 호출(method call)

```
int result = plus(100, 200);

// 의미
result: 리턴 값을 받는 변수
plus: 메서드명
100, 200: 아규먼트 (argument)
```

### 메서드

#### 메서드 호출과 메모리

1. 클래스 로딩
2. `main()` 호출
3. 로컬 변수 생성
4. `swap()` 호출
5. `swap()`이 사용할 로컬 변수 준비
6. 아규먼트 저장

- 종료. JVM이 OS로 부터 받아서 쓴 모든 메모리를 OS가 회수

#### Call by reference

1. 클래스 로딩
2. `main()` 호출
3. 로컬 변수 준비
4. 배열 인스턴스 생성

#### 클래스와 메모리

1. 클래스 로딩
2. `main()` 호출
3. `main()`에서 사용할 로컬 변수 준비
4. 클래스 로딩
5. MyObject 설계도에 따라 변수 생성
6. `swap(주소)`
7. `swap()`을 실행하는 동안 사용할 로컬 변수 준비

### 메서드 블록의 명령 실행

#### 과정

1. `hello()` 메서드의 블록으로 이동
2. 메서드 바디를 실행
3. 다시 원래 위치로 돌아옴
4. 다음 줄을 실행

### 가변 파라미터 vs 배열 파라미터

#### 가변 파라미터

- 낱개의 값을 여러 개 줄 수 있음
- 배열에 담아서 전달할 수 있음
- 반드시 맨 뒤에 와야 함 => 복잡한 사용 방지

#### 배열 파라미터

- 낱개의 값을 여러 개 줄 수 없음
- 오직 배열에 담아서 전달해야 함
- 순서는 상관 없음

### JVM의 메모리 구조

#### Method Area

- 자바 코드를 두는 영역
  - 클래스 코드
  - 상수
  - 클래스 변수

#### JVM Stack

- 메서드를 호출할 때 생성되는 로컬 변수를 둠

#### Heap

- new 명령으로 생성하는 변수(= 인스턴스 변수)를 둠

## :pushpin: Day 14

### 메서드: JVM 메모리

#### 실행 순서와 메모리

1. `$ java -classpath bin ···`

- JVM은 클래스 정보를 Method Area 영역에 로드

2. `main()` 호출

- JVM Stack 영역에 `main()` 메서드가 사용할 로컬 변수를 준비

3. `swap()` 호출

- JVM Stack 영역에 `swap()` 메서드가 사용할 로컬 변수를 준비

4. `swap()` 실행 완료

- JVM Stack 영역에 있던 `swap()`이 사용한 메모리를 제거

5. `main()` 실행 완료

- JVM Stack 영역에 있던 `main()`이 사용한 메모리를 제거

6. JVM 실행 종료

- OS가 JVM에게 사용하라고 빌려줬던 모든 메모리를 회수

#### JVM이 메모리를 다루는 방법

- Method Area
  - 클래스 명령 코드
  - static 변수
- Heap
  - new 명령으로 만든 메모리 (인스턴스 = 객체)
  - Garbage Collector(GC)가 관리하는 영역
- JVM Stack
  - 메서드의 로컬 변수
  - 스레드 별로 JVM Stack 메모리를 따로 관리
  - 각 메서드마다 프레임 단위로 관리
  - 메서드 호출이 끝나면 그 메서드가 사용한 프레임 메모리 제거
  - 스택(Stack) 메모리
  - 스택 방식 => Last In First Out (LIFO; 후입선출)
  - ex) 접시 쌓기
  - 메서드가 호출될 때 로컬 변수가 준비
  - 맨 마지막에 호출한 메서드가 먼저 삭제
  - JVM이 종료하면 JVM이 사용했던 모든 메모리를 OS가 회수

### 메서드: Heap 메모리 영역

1. `main()` 호출

- JVM Stack: args, arr 변수 생성

2. `getArray()` 호출

- JVM Stack: arr 변수 생성
- Heap: `new int[]` 배열 생성

3. `getArray()` 호출 끝

- JVM Stack: `getArray()` 관련 메모리(arr 변수) 제거
- `new int[]` 배열 주소 리턴

4. `main()` 호출 끝

- JVM Stack: `main()` 관련 메모리 제거

5. JVM 종료

- JVM이 사용한 모든 메모리(Method Area, JVM Stack, Heap 등)를 OS 반납

### 배열의 생성

- 호출하는 쪽에서 결과를 담을 배열을 주는 경우
- 메서드 쪽에서 결과를 담을 배열을 만들어 리턴하는 경우

### 메서드: 인스턴스와 Heap 메모리 영역

- Heap 메모리에 어떤 변수를 만들어야 하는지 적어 놓은 설계도
- new 명령을 사용하여 메모리를 만들라고 하면 => MyObject

1. `main()` 호출

- JVM Stack: args, ref 변수 생성

2. `getMyObject()` 호출

- JVM Stack: ref 변수 생성
- Method Area: MyObject 클래스를 로딩
- Heap: MyObject 설계도에 따라 인스턴스 생성

3. `getMyObject()` 호출 끝

- JVM Stack: `getMyObject()` 관련 메모리(ref 변수) 제거
- MyObject의 인스턴스의 주소 리턴

4. `main()` 호출 끝

- JVM Stack: `main()` 관련 메모리 제거

5. JVM 종료

- JVM이 사용한 모든 메모리(Method Area, JVM Stack, Heap 등)를 OS 반납

### 메서드: 스택 메모리 응용 I

#### JVM Stack 메모리의 사용

1. main()
2. main() -> m1()
3. main() -> m1() -> m2()
4. main() -> m1()
5. main() -> m1() -> m3()
6. main() -> m1()
7. main()
8. 종료

### 메서드: 스택 메모리 응용 II - 재귀호출

- 작은 수를 계산 할 때는 재귀호출을 사용
- => 코드도 간단하고 이해하기도 쉬움

#### JVM Stack 메모리의 사용

1. main()
2. main() => sum(5)

- => 5 + sum(4)
- => 4 + sum(3)
- => 3 + sum(2)
- => 2 + sum(1)
- => 1

3. main()
4. 종료

#### 재귀호출 (Recursive Call)

- 메서드가 호출 => 스택에 그 메소드가 사용할 변수가 생성
- 수학식을 코드를 표현하기가 편함
- 코드가 간결
- 반복문을 사용하는 경우보다 메모리를 많이 사용
- 메서드 호출이 너무 깊게 들어가지 않는 상황에서 사용

### 메서드: 스택 오버플로우 오류

#### 스택 오버플로우(Stack Overflow)

> JVM 스택 메모리가 꽉 차서 더이상 메서드 실행을 위해 로컬 변수를 만들 수 없는 상태

- 멈춰야 할 조건 누락 -> 스택 메모리 극한으로 증가 -> 메모리 부족 사태
- 호출하는 메서드의 로컬 변수가 클 때 스택 메모리가 빨리 참
- 호출 단계가 많은 큰 수를 다룰 때는 재귀호출 대신 반복문을 사용
- 메서드 호출 회수에 영향 X
- 메서드에서 생성하는 로컬 변수의 크기에 영향 O

## :pushpin: Day 15

### 클래스 문법

#### 용도

- 서로 관련된 일을 하는 메서드들을 관리하기 쉽게 한 클래스에 모아둠
- => 역할에 따라 메서드 분류
- 복합 데이터를 저장하는 메모리를 설계
- => 사용자 정의 데이터 타입(User-defined data type) 만들 때

#### 복합 구조의 변수 설계

- 낱개의 변수로 여러 사람의 정보를 다룸
- -회원 정보를 관리하기 쉽게 한 묶음으로 묶기->
- 여러 개의 변수로 구성된 새로운 구조의 복합 데이터 타입을 정의

### Member 인스턴스 생성

```
Member member = new Member();

/* Member: 클래스명 (변수의 데이터 타입)
   member: Member 인스턴스의 주소를 저장하는 변수 = "Member의 레퍼런스"
   new: 클래스 설계도에 따라 Heap 영역에 변수를 만들라는 명령
   Member: 클래스명 */
```

## :pushpin: Day 16

### 인스턴스 사용법: 인스턴스 필드가 필요한 이유와 사용법

- static 변수(필드) = 클래스 변수(필드)
  - .class 파일이 Method Area 영역에 로딩될 때 생성
  - 클래스 당 한 번만 생성
  - 여러 개의 게시판을 다룰 수가 없음

#### 해결책

- static 필드를 인스턴스 필드로 전환
  - new 명령으로 필요할 때마다 생성 가능

## :pushpin: Day 17

### 스태틱 변수 = 클래스 변수

#### where

- Method Area

#### when

- 클래스 로딩 -> 생성
- 언로드 될 때 -> 제거

#### load

- 클래스를 최소 사용할 때

#### unload

- JVM 종료 or 클래스 로더가 강제 언로드

#### 저장

- 특정 인스턴스에 상관없이 공유할 값을 저장할 때 사용

### 논 스태틱 변수 = 인스턴스 변수

#### where

- Heap

#### when

- new 명령 실행 시마다 생성
- 가비지가 된 후 가비지 컬렉터가 수집할 때 제거

#### 저장

- 인스턴스 마다 구분해서 관리해야 할 데이터를 저장

### 클래스 문법

1. 메서드 분류

- 소스 코드를 유지 보수하기 쉬움
- 재사용성이 높아짐

2. 새 데이터 타입 설계

## :pushpin: Day 18

### Static Field

#### 영역

- Method Area

#### Lifecycle

##### 생성

- 클래스가 로딩

##### 소멸

- 클래스가 언로드
- JVM 종료

### Non-Static Field

#### 영역

- Heap

#### Lifecycle

##### 생성

- new App() 실행

##### 소멸

- 가비지 컬렉터가 수집
- JVM 종료

### Local Field

#### 영역

- JVM Stack

#### Lifecycle

##### 생성

- 메서드가 호출

##### 소멸

- 메서드 호출 끝

### Static Method

- 인스턴스 없이 호출
- 클래스명.메서드명()
- 클래스 메서드라 부름

### Instance Method

- 인스턴스가 있어야만 호출
- 레퍼런스.메서드명()
- 메서드를 호출할 때 지정한 인스턴스 주소는 `this` 라는 내장 변수에 보관

### Class 문법

#### BoardHandler

- 메서드 분류
- 기능 중심

#### Board

- 새 데이터 타입 설계
- 데이터 중심

### 명령의 의미

#### `new BoardHandler()`

1. BoardHandler의 인스턴스 생성
2. BoardHandler 설계도에 따라 변수를 준비하라
3. BoardHandler의 메서드가 실행하는 동안 사용할 변수를 준비하라

#### `new Board()`

1. Board의 인스턴스 생성
2. Board 설계도에 따라 인스턴스 변수를 준비하라
3. Board 데이터를 저장할 변수를 준비하라

## :pushpin: Day 19

### 클래스 멤버의 종류

- 변수
- 메서드

### 주소 값 위치

#### static

- 파라미터

```
Calculator.plus(c1, 1);
```

#### instance

- 맨 앞

```
c1.plus(1);
```

## :pushpin: Day 20

### 관리 시스템에서 데이터 처리의 기본 기능

#### CRUD 구현 | 리팩토링

- 생성 (Create)
- 조회 (Read/Retrieve)
- 변경 (Update)
- 삭제 (Delete)

## :pushpin: Day 21

### 의존 객체

- 하나의 클래스가 static/non-static 메서드를 호출
- ex) System.out의 out

### 클래스 간의 관계

#### 일시적인 의존 관계 (Dependency)

- 특정 메서드에서 일시적으로 사용
  - 파라미터
  - 로컬 변수

#### 지속적인 연관 관계 (Association)

- 여러 메서드에서 지속적으로 사용
  - 인스턴스 필드

## :pushpin: Day 22

### 생성자 (constructor)

- 모든 클래스는 반드시 한 개 이상의 생성자가 존재

#### 호출 방법

- 인스턴스를 생성하는 new 명령에서 호출할 생성자의 파라미터 값을 지정
- 파라미터 값을 주지 않으면 기본 생성자를 호출

#### 존재 이유

- 생성된 인스턴스가 제대로 쓰일 수 있도록 유효한 값으로 초기화시키는 작업을 수행

#### 다른 생성자 호출

- 단, 첫 문장으로 와야 함
- 생성자의 첫 문장에 this()를 사용해야 함

#### 클래스 로딩

1. 클래스 멤버(필드와 메서드)를 최초로 사용할 때
2. 클래스 멤버(필드와 메서드)를 최초로 사용할 때
3. 해당 클래스의 인스턴스를 최소로 생성할 때
4. 자바에서 제공하는 도구를 사용하여 클래스를 로딩할 때

#### 인스턴스 필드 초기화 문장

- 생성자의 앞 부분에 삽입
- 여러 개의 생성자가 있으면 모든 생성자에 삽입
- 선언된 순서대로 모든 생성자의 앞 부분에 삽입

#### 생성자 유무

- 유: 존재하는 생성자의 앞 부분에 삽입
- 무: 기본 생성자가 생성되어 앞 부분에 삽입

#### 코드 작성 순서

1. 필드 선언 및 초기화 문장
2. 스태틱 블록 (가능한 한 개의 블록으로 묶기)
3. 인스턴스 블록 (가능한 한 개의 블록으로 묶기)
4. 생성자 (기본 생성자를 먼저 두고 파라미터 개수에 따라 나열)

## :pushpin: Day 23

### 생성자

> 인스턴스를 생성한 후 그 인스턴스를 제대로 쓸 수 있도록 유효한 값으로 초기화 시키는 일을 하는 메서드

### 기능 추가

1. 기존 클래스 파일에 추가하는 방법

- 기존 코드를 변경하게 되면 원래 되던 기능도 오류가 발생할 수 있는 위험 발생
- 그래서 원래 코드를 손대는 것은 매우 위험한 일
- 기존에 잘 되던 기능까지 동작이 안되는 문제가 발생할 수 있음

2. 기존 코드를 복사하여 새 클래스를 만드는 방법

- **장점**
  - 기존 코드를 손대지 않기 때문에 문제가 발생할 가능성은 줄임
- **단점**
  - 기존 코드의 크기가 큰 경우에는 복사 붙여넣기가 어려움
  - 기존 클래스의 소스가 없는 경우에는 이 방법이 불가능
  - 기존 코드에 버그가 있을 때 복사 붙여넣기 해서 만든 클래스도 영향을 받음
  - 기존 코드를 변경했을 때 복사 붙여넣기 한 모든 클래스를 찾아 변경해야 함

3. 기존 코드를 상속 받아 기능을 추가하는 방법

- **장점**
  - 기존 클래스의 소스 코드가 필요 없음
  - 간단한 선언으로 상속 받겠다고 표시한 후 새 기능만 추가하면 됨
- **단점**
  - 일부 기능만 상속 받을 수 없음
  - 쓰든 안쓰든 모든 기능을 상속 받음

## :pushpin: Day 24

### 상속 기법

#### Specialization (전문화)

- 수퍼 클래스를 상속 받아서 서브 클래스를 만드는 것

#### Generalization (일반화)

- 서브 클래스들의 공통 코드를 추출하여 수퍼 클래스를 만드는 것

### 상속 - 추상 클래스

> 서브 클래스에 공통 기능을 상속해주는 용도로 만든 클래스를 직접 사용하지 못하도록 막기위해 만든 문법

### 상속 - 추상 메서드

> 수퍼 클래스에서 정의하지 않고 서브클래스에 반드시 정의하도록 강제하는 문법

### 다형성 - 다형적 변수(Polymorphic Variables)

- 레퍼런스가 실제 하위 인스턴스를 가리키고 있다 하더라도, 레퍼런스 타입의 범위를 벗어나서 사용 불가

#### Why

- 자바 컴파일러는 레퍼런스가 실제 어떤 인스턴스를 가리키는지 따지지 않고 레퍼런스의 타입에 한정하여 인스턴스나 클래스의 멤버 사용을 허락

#### 해결책

- 레퍼런스 변수가 실제 가리키는 것이 무엇인지 알려줘야 함

```
((원래인스턴스타입) 레퍼런스).멤버
```

- 인스턴스의 원래 클래스 레퍼런스에 저장한 다음에 사용

### 다형성 - 다형적 변수와 instanceof 연산자

#### instanceof 연산자

- 레퍼런스에 들어있는 주소가 특정 클래스의 인스턴스인지 검사
- 하위 클래스의 인스턴스인지 검사
- 인스턴스의 주소가 어떤 클래스의 주소인지 판단할 수 있는 연산자를 제공

#### getClass()

- 레퍼런스가 가리키는 인스턴스의 실제 클래스 정보를 리턴
- == 연산자를 사용하여 특정 클래스의 인스턴스인지 좁혀서 검사 가능

### 오버로딩

> 파라미터의 형식 (타입과 개수)은 다르지만 같은 기능을 수행하는 메서드에 대해 같은 이름을 부여함으로써 프로그래밍의 일관성을 제공하기 위한 문법

- 메서드를 찾을 때 아규먼트의 타입과 일치하는 메서드를 찾기 때문에 메서드의 파라미터 이름은 아무 상관이 없음
- 호출하는 메서드 이름은 같지만, 아규먼트의 타입이나 개수에 따라 호출되는 메서드가 결정

#### 규칙

1. 파라미터 타입이 달라야 함
2. 파라미터 개수가 달라야 함
3. 파라미터 이름이 다른 것으로는 메서드를 구분할 수 없음
4. 접근 범위는 상관없음

## :pushpin: Day 25

### this.메서드() 호출

> 현재 클래스부터 호출할 메서드를 찾아 올라 감

- `this`가 실제 가리키는 인스턴스 클래스를 기준으로 메서드를 찾아 올라감

### super.메서드() 호출

> 수퍼 클래스부터 호출할 메서드를 찾아 올라 감

- 소속된 클래스를 기준으로 수퍼 클래스부터 메서드를 찾아 올라감

### 오버라이딩(overriding) - 리턴 타입

#### 가능

- 메서드를 오버라이딩 할 때 리턴 타입으로 서브 클래스도 가능

#### 불가능

- 메서드를 오버라이딩 할 때 리턴 타입으로 수퍼 클래스는 불가능

### 오버라이딩 문법

- 메서드명, 파라미터 형식, 리턴 타입 동일해야 함
- 파라미터의 이름은 달라도 무방

### 오버라이딩 문법 검사

> 오버라이딩을 제대로 했는지 컴파일러에게 검사하도록 요청 가능

```
/* 컴파일러야, 내가 상속받은 메서드를 재정의한다고 했는데
   혹시 실수는 없는지 검사해 줄래? */
@Override
```

### 멤버의 접근 범위

#### private

- 같은 클래스

#### (default)

- 같은 클래스 + 같은 패키지

#### protected

- 같은 클래스 + 같은 패키지 + 서브 클래스

#### public

- 모두

### 다형적 변수와 오버라이딩 - 레퍼런스와 메서드 호출

1. 다형적 변수의 사용법에 따라, super 클래스 레퍼런스로 하위 클래스의 인스턴스를 가리킴
2. 오버라이딩 메서드 호출 규칙에 따라, 레퍼런스가 실제 가리키는 객체의 클래스부터 메서드를 찾아 올라감

### final 사용법

#### 상속 불가

- 클래스에 final 을 붙이면 이 클래스의 서브 클래스 생성 불가

#### 오버라이딩 불가

- 메서드에 final 을 붙이면 서브 클래스에서 오버라이딩 불가

### 캡슐화 (Encapsulation)

> 자바는 필드나 메서드의 외부 접근 범위를 조정하는 문법을 제공

- 외부의 접근 제한 및 세터/게터 메서드를 통해 값을 설정/조회하게 만듬

## :pushpin: Day 26

### 캡슐화

#### 같은 패키지

- ~~private~~
- default
- protected
- public

#### 다른 패키지

- ~~private~~
- ~~default~~
- ~~protected~~
- public

#### 서브 클래스

- ~~private~~
- ~~default~~
- protected
- public

### 추상화

> 실세계의 객체 (ex: 사람, 물건, 업무, 개념 등)를 컴퓨터에서 다룰 수 있도록 클래스로 정의하는 행위

#### 기법

- 데이터 타입을 정의
- 연관 메서드를 묶기

### Factory Method

- 인스턴스 생성과정이 복잡할 경우에 이용하는 방법
- 인스턴스를 생성해 주는 메서드를 통해 인스턴스를 생성하면 코드가 간결

### 다형성

- 다형적 변수
- 오버 로딩
- 오버 라이딩

## :pushpin: Day 27

### 클래스 관계

1. 상속
2. 연관 (association)
3. 집합 (aggregation)
4. 합성 (composition)
5. 의존 (dependency)

### 리스너 호출 규칙

- 리스너의 메서드가 각각 다르다면 정의하는 입장에서 호출할 메서드를 결정할 수 없어서 코딩을 할 수 없는 문제가 발생

### 인터페이스

> 메서드 호출 규칙을 정의하는 문법

### 추상 메서드

- 인터페이스로 메서드 호출 규칙을 정의하는 것이 목적이기 때문에 추상 메서드로 선언

### 메서드 구현

- 메서드의 body를 작성
- 인터페이스를 구현하는 클래스는 인터페이스의 모든 추상 메서드를 반드시 구현해야 함

## :pushpin: Day 28

### 타입과 변수

#### primitive type

- boolean
- 숫자 - 정수: byte, short, int, long, char - 부동 소수점: float, double
  `int a;`
- type: 변수의 크기와 변수에 저장할 수 있는 값의 범위를 설정
- 변수 크기: 4byte
- 값의 범위: 약 -21억 ~ +21억 정수 값

#### reference type

- class
- interface
- arr
  `Car c;`
- type: class
- 변수 크기: 주소를 저장하는 크기 (4byte, 8byte)
- 값의 범위: 타입에 따라 저장할 수 있는 인스턴스 주소가 다름

### 타입별 레퍼런스의 크기

> 타입에 상관없이 레퍼런스 변수의 크기는 같다

#### Why

- 주소를 저장하는 변수이기 때문에

### 타입별 인스턴스 크기

1. 수퍼 클래스의 인스턴스 변수 생성
2. 해당 클래스의 인스턴스 변수 생성

## :pushpin: Day 29

### 캡슐화

> 복잡한 코드를 감춰서 단순화 시키자

### 캡슐화의 이점

- 메서드를 이용하는 측에 영향을 주지 않으면서 기능의 구현을 변경 가능

### GRASP

1. Information Expert
2. Low Coupling
3. High Cohesion

- 교체 및 유지 보수 편리

4. Creator

### 설계 패턴

#### GRASP

- OOP 기초 설계 패턴

#### GoF Design Patterns

- OOP 응용 설계 패턴

## :pushpin: Day 30

### 구조 변경 이유

- ~~더 객체지향 다워서~~
- 유지 보수하기 더 쉬운 구조

### Generalization

#### 의문

- 서브 클래스 입장에서는 추상 메서드만 갖고 있는 클래스를 상속 받는 것은 아무런 도움이 되지 않음

#### 이점

1. 같은 수퍼 클래스를 상속 받음으로써 같은 타입으로 묶을 수 있음

- 하나의 타입으로 다룰 수 있어 편리
- 다형성을 활용 가능

2. 비록 구현한 것은 없지만 추상 메서드를 상속받게 함으로써 메서드 시그너처를 통일 가능

- 메서드 호출에 일관성 부여 = 클래스 사용법이 동일

### Method Signature

- 메서드명
- 파라미터 타입/순서/개수
- ~~리턴 타입~~

### 추상 클래스

- Generalization을 통해 수퍼 클래스를 정의한 경우 그 수퍼 클래스는 서브 클래스의 공통 분모를 모아두는 용도로 만든 것
- ~~직접 사용하기 위해 만든 클래스~~
- 서브 클래스에게 공통 분모를 상속해주기 위한 역할
- 직접 인스턴스를 만들어 사용하지 않도록 추상 클래스로 선언하는 것이 유지 보수에 적합
- 특히 추상 메서드를 갖는 경우에는 더더욱 무조건 추상 클래스로 선언

### 추상 메서드

- 서브 클래스에서 목록을 다루는 방식에 따라 구현 방법에 차이 발생
- 수퍼 클래스에서 구현해도 소용 X
- 구현하지 않은 채로 두는 것이 나을 경우 선언

### 인터페이스

> 메서드 호출 규칙 = 객체 사용 규칙

#### Client

- 객체를 사용하는 측
- 객체의 메서드 호출

#### 객체

- 사용되는 객체

#### 정의

- 객체 사용 규칙을 정의할 때 사용하는 문법
- 인스턴스 생성 불가
- 모든 필드 = public, static, final 필드
- 모든 메서드 = public, abatract 메서드
- default 키워드를 이용 -> 구현 메서드 생성 가능

#### 사용 이유

- 필드나 메서드를 상속해주는 역할이 아니라 여러 객체를 한 타입으로 묶어주는 역할을 하면서, 각 객체가 해야할 일을 규칙으로 정의하는 것이 가능하기 때문

#### 활용

- 뭔가를 상속해주는 역할은 하지 않고 해야할 일(= 메서드)만 강요하는 경우
- 같은 타입으로 묶으면서 구현 규칙을 정의하는 경우

#### Inplementor

> 규칙에 따라 만든 클래스

### 인터페이스 vs 상속

#### 인터페이스

- 다중 구현 가능

#### 상속

- 다중 상속 불가

### Concrete

- 완성된 클래스

### Stereotype

- 고정관념
- 라벨 (역할, 문법)

## :pushpin: Day 31

### 추상 클래스와 인스턴스

#### 추상 클래스

- 추상 메서드는 구현할 수 없음

#### 인스턴스

- 서브 클래스에서 추상 메서드를 구현해야 함
- 서브 클래스에서 추상 메서드를 구현하지 않는다면, 추상 메서드인 채로 남아 있기 때문에 추상 클래스가 되어야 함

### Type

- Primitive Type
- Class
- Interface

### 추상 클래스와 추상 메서드의 활용

- 추상 메서드를 하나라도 갖고 있는 클래스는 인스턴스 생성을 못 하기 때문에 추상 클래스를 상속받은 서브 클래스에서 인스턴스를 생성해야 함
- **인스턴스를 생성했다는 것**은 서브 클래스가 추상 메서드를 구현했다는 뜻이며 추상 메서드가 하나라도 있는 메서드는 일반 클래스가 X

#### 템플릿 메서드 디자인 패턴

- 세부 사항에 대한 것은 서브 클래스에게 구현을 맡김
  - 템플릿의 역할을 하는 메서드를 둚
  - 자세한 구현은 서브 클래스에게 맡김
- 상세한 기능에 대한 구현은 다음과 같이 서브 클래스에게 맡김

### Object 클래스 - equals()에 대하여

- Object에서 상속 받은 것을 그대로 사용하면 equals()는 인스턴스가 같은지 비교
- 인스턴스의 내용물이 같은지 비교하도록 만들고 싶다면 equals()을 오버라이딩

### Object 클래스 - 자바 최상위 클래스

#### Object 클래스의 주요 메서드

1. `toString()`

- 클래스이름과 해시코드를 리턴

2. `equals()`

- 같은 인스턴스인지 검사

3. `hashCode()`

- 인스턴스를 식별하는 값을 리턴

4. `getClass()`

- 인스턴스의 클래스 정보를 리턴

5. `clone()`

- 인스턴스를 복제한 후 그 복제 인스턴스를 리턴

6. `finalize()`

- 가비지 컬렉터에 의해 메모리에서 해제되기 직전에 호출

### 해시 코드 = 디지털 지문

#### 사람

- 지문: 사람을 구분할 때 사용하는 것

#### Data

- 디지털 지문: 데이터를 구분할 때 사용하는 식별 번호 (정수 값)

#### 해시 값 (Hash Value)

- 지문 + 디지털 지문

### 해시 알고리즘

> 해시 값을 생성하는 수학 공식

- Data를 특별한 수학 공식으로 계산하여 만든 정수 값
- 원래 데이터를 요약한 값
- 원래 데이터보다 크기가 작음

#### 문제점

- 서로 다른 데이터가 같은 해시 값을 가질 수 있음

### 해시 알고리즘과 계산 시간

#### MD5 -**시간 ↓**/**중복될 확률 ↑**-> 해시 값

- 중복될 확률보다는 시간이 짧은게 더 중요한 경우
- 중요도가 낮은 경우

#### SHA -**시간 ↑**/**중복될 확률 ↓**-> 해시 값

- 시간이 오래 걸리더라도 중복 가능성이 낮은 것이 더 중요한 경우
- 보안 관련 데이터
  - ex) 인증서

### 해시 값(디지털 지문) 사용처

> 원본을 비교하는 것보다 요약 데이터, 즉 해시 값을 비교하는 것이 훨씬 시간이 적게 듦

#### 정확도

100% <-> 0%

#### 시간 소요

높다 <-> 낮다

1. DNA
2. 지문
3. 겉모양

#### 정확도

100% <-> 0%

#### 시간 소요

높다 <-> 낮다

1. 1byte 씩 순서대로 비교
2. 요약 데이터 (해시 값)
3. 파일 크기

### 해시 값 활용 예 1

- 파일 공유 사이트 -> 같은 파일인지 비교할 때
  - ex) edonkey
- 여러 사람으로 부터 여러 조각을 받아서 합침
  - 다운로드 속도가 빠름

## :pushpin: Day 32

### 해시 값 활용 예 2

- 원본 파일인지 검사할 때 -> 해커에 의해 왜곡된 데이터가 아닌지 검사할 때

### Object

#### `hashCode()`

- 인스턴스가 다르면 다른 해시 값 리턴

#### `equals()`

- 인스턴스가 같은지 비교

#### `toString()`

- "패키지명.클래스명@해시값"

#### ↓ Overriding

### String

#### `hashCode()`

- 문자열이 같으면 같은 해시 값 리턴

#### `equals()`

- 문자열이 같은지 비교

#### `toString()`

- this 값 리턴

#### Hash Value

- 데이터를 다른 데이터와 구분하기 위해 사용하는 특별한 정수 값
- 특정 수학 공식(MD4, MD5, SHA, PGP, CRC 등)에 따라 값을 계산
- 데이터가 같은지 비교할 때 사용
- 모든 데이터를 바이트 단위로 일일이 비교하는 대신에 미리 생성된 정수 값을 비교함으로써 빠르게 두 값이 같은지 알아낼 수 있음

#### 목적

- 데이터가 같은지 빠르게 비교하기 위함

#### 응용

- 본인 여부를 확인하는 인증서
- 파일의 위변조를 검사하는 용도

### Object 클래스 - `hashCode()`

#### Hash Code

- 데이터를 식별할 때 사용하는 고유 아이디
- 보통 데이터를 특별한 공식(ex: MD4, MD5, SHA-1, SHA-256 등)으로 계산해서 나온 정수 값을 해시코드로 사용
- 데이터를 구분하는 지문과 같다고 해서 **디지털 지문**이라고 부름

#### `hashCode()`를 오버라이딩 할 경우

- 인스턴스(메모리)가 다르더라도 같은 데이터를 갖는 경우 같은 것으로 취급하기 위해 메서드를 재정의
- 데이터가 같은지 따지지도 않고 모든 인스턴스에 대해 같은 해시코드를 리턴하는 것은 아무 의미 X

### Object 클래스 - `clone()`

> 인스턴스를 빠르고 쉽게 복제하는 방법

#### `clone()`

- 인스턴스 변수와 값을 그대로 복제

#### 제약조건

1. `clone()` 오버라이딩하고 public으로 공개
2. cloneable 인터페이스 구현

### 오버라이딩 규칙

- 오버라이딩은 접근 범위를 좁힐 수는 없지만, 넓힐 수는 있음
- 오버라이딩 할 때 리턴 타입을 해당 클래스의 타입으로 변경 가능

#### 가능한 경우

1. 접근 범위를 더 넓힘
2. 리턴 타입은 서브 클래스 타입으로 변경

#### `clone()`을 오버라이딩할 때

- 접근 범위는 public으로 넓힘
- 리턴 타입은 서브 클래스 타입으로 정확하게 지정

#### Shallow Copy

- Object의 `clone()`은 해당 객체의 필드 값만 복제
- 주소만 복제할 뿐, 그 인스턴스 변수가 가리키고 있는 객체는 복제 X

#### Deep Copy

- 객체의 인스턴스 변수가 가리키고 있는 의존 객체까지 복제
- 포함하고 있는 하위 객체에 대한 복제를 수행하려면 개발자가 직접 하위 객체를 복제하는 코드를 작성해야 함

### Object 클래스 - `getClass()`

- 레퍼런스를 통해서 인스턴스의 클래스 정보를 알아낼 수 있음
- 클래스 정보로부터 다양한 값을 꺼낼 수 있음

### String - 문자열 리터럴

#### 순서

1. Method Area 영역에 String 인스턴스 생성
2. 기존에 같은 문자열이 이미 있다면 기존 인스턴스의 주소를 리턴
3. JVM이 끝날 때까지 메모리에 유지

#### Why

- 메모리 절약을 위해 중복 데이터를 갖는 인스턴스를 생성 X

### String - `intern()`

> Method Area에 이미 존재하는 String 인스턴스 주소를 리턴

#### `intern()`

- 지정된 String 객체를 상수풀에서 찾음
- 있으면 그 String 객체의 주소를 리턴
- 없으면 상수풀에 String 객체를 생성한 후 그 주소를 리턴

### String - `equals()`

#### `equals()`

- Object에 정의되어 있는 메서드
- 인스턴스가 같은지 비교

#### String의 `equals()`

- Object에서 상속 받은 것을 오버라이딩
- 문자열이 같은지 비교

### Object 클래스 메서드

#### `equals()`

- 인스턴스가 같은지를 비교

#### `toString()`

- 인스턴스의 클래스명과 해시코드를 리턴

#### `hashCode()`

- 인스턴스의 해시 코드를 리턴

#### `getClass()`

- 클래스 정보를 리턴

#### `clone()`

- 인스턴스를 복제하여 리턴

#### `finalize()`

- 가비지 컬렉터에 의해 제거되기 전에 호출

#### `wait()`

- 잠시 실행을 멈춤
- 외부에서 깨워줄 때까지 멈춤

#### `notify()`

- wait()로 실행을 멈춘 것을 깨움

#### `notifyAll()`

- wait()로 실행을 멈춘 것을 모두 깨움

### String - Mutable vs Immutable 객체

#### Immutable 객체

- String 객체 = immutable 객체
- 한 번 객체에 값을 담으면 변경 불가
- String 클래스의 메서드는 원본 인스턴스의 데이터를 변경 X -> 새로 String 객체를 생성

#### Mutable 객체

- StringBuffer 객체 = mutable 객체
- 인스턴스의 데이터를 변경 가능
- 원래의 문자열을 변경하고 싶을 때 사용하는 클래스

## :pushpin: Day 33

### Wrapper 클래스

> primitive 값을 객체화하는 용도로 사용하기 위해 만든 클래스

- primitive type의 값을 객체로 포장하는 역할 수행
- Wrapper 클래스의 인스턴스를 생성할 때는 생성자 대신 클래스 메서드를 사용
- primitive type에 상관없이 Object 타입의 파라미터로 값을 받을 수 있음 => 모든 객체를 받을 수 있음

#### Wrapper 클래스의 주요 용도

- primitive data type의 값을 객체로 주고 받을 때 사용
- primitive data type의 값을 객체에 담아 전달하고 싶다면 언제든 wrapper 클래스의 인스턴스를 생성하면 됨

#### Wrapper 클래스의 가장 큰 목적

- primitive 값을 포함하여 모든 값을 쉽게 주고 받기 위함
- wapper 클래스가 없다면, 각 타입에 대한 메서드가 따로 있어야 함
- wrapper 클래스를 사용하면 객체로 다룰 수 있음

### Type

- 클래스
- 추상 클래스
- 인터페이스

#### primitive type

- byte
- short
- int
- long
- float
- double
- boolean
- char

#### Wrapper 클래스 (java.lang)

- Byte
- Short
- Integer
- Long
- Float
- Double
- Boolean
- Char

### primitive type <-> Wrapper

#### int -> Integer

1. Integer.valueOf(int)
2. ~~new Integer(int)~~ **Deprecated**
3. Obj.intValue()

### auto-boxing과 auto-unboxing

- 코드의 문맥에 따라 Boxing과 Unboxing을 자동으로 수행
- primitive data type 값을 Wrapper 클래스의 인스턴스에 바로 할당 가능

#### auto-boxing

> Wrapper 객체 자동 생성

##### boxing

- primitive type의 값을 인스턴스에 담는 일

##### 컴파일러 변환

```
printInt(obj.intValue())
```

- Wrapper 객체의 주소가 레퍼런스에 저장됨

#### auto-unboxing

> Wrapper 객체에 들어있는 값을 자동으로 꺼냄

##### unboxing

- 인스턴스의 담긴 primitive 값을 다시 꺼내는 일

##### 컴파일러 변환

```
printObject(Integer.valueOf(int))
```

- Wrapper 객체에 보관된 int 값을 꺼내 변수에 저장

## :pushpin: Day 34

### 인터페이스와 추상 클래스 : 인터페이스 직접 구현

> 인터페이스를 준수한다는 것은 인터페이스의 모든 규칙을 구현해야 함을 의미

### 인터페이스와 추상 클래스 : 추상 클래스의 도움 받기

> 추상클래스에서 인터페이스의 규칙을 모두 최소 상태로 미리 구현

- 인터페이스를 준수하는 클래스를 만들어야 할 경우, 직접 인터페이스를 구현하는 대신에 추상 클래스를 상속 받음
- 수퍼 클래스에서 인터페이스를 구현했다면, 그 서브 클래스들도 인터페이스를 구현한 것이 됨

#### 장점

- 오버라이딩을 통해 인터페이스 규칙 중 필요한 규칙만 구현할 수 있음

- 수퍼 클래스가 인터페이스를 구현했다면, 그 서브 클래스는 자동으로 인터페이스를 구현한 것이 됨

### 인터페이스와 추상 클래스 : 추상 클래스의 도움 받기

#### 1) 인터페이스 정의

- 인터페이스는 사용규칙을 정의한 것
- 그래서 인터페이스에 선언하는 모든 메서드는 추상 메서드이어야 함

#### 2) 추상 클래스로 인터페이스의 일부 규칙 구현하기

- 추상 클래스의 목적은 서브 클래스에게 공통 필드와 공통 메서드를 상속해주는 것
  - 그 중에서 인터페이스에 선언된 메서드의 일부를 미리 구현해 주면 서브 클래스를 만들기가 매우 편리
  - 즉 인터페이스의 메서드 중에서 서브 클래스가 구현해야만 의미가 있는 메서드의 경우 추상 클래스에서 미리 구현할 필요가 없음
  - 서브 클래스가 구현하도록 강제하기 위해 추상 메서드로 내비 둠
  - 인터페이스의 메서드를 구현하지 않는다면 다음과 같이 추상 메서드인채로 남겨짐

#### 3) 인터페이스 직접 구현하기

- 인터페이스에 따라 클래스를 작성하면 사용하는 쪽에서 일관된 방식으로 메서드를 사용할 수 있음
- 인터페이스를 구현한다는 것은 인터페이스에 선언된 모든 메서드를 정의함을 의미

#### 4) 인터페이스 간접 구현

- 인터페이스를 구현한 클래스를 상속 받는다면 결국 인터페이스를 구현한 것이 됨
- 서브 클래스는 수퍼 클래스가 구현하지 않은 나머지 메서드만 구현하면 됨

#### 5) 인터페이스 규칙에 따라 구현체 사용하기

### 인터페이스: default의 활용

> 인터페이스에 새 규칙(메서드)을 추가하는 순간 기존의 구현 클래스들에서 오류 발생

### 인터페이스에 새 규칙을 추가하는 방법: 상속

- 기존 규칙을 상속받아 새 규칙을 추가 -> 기존 규칙을 손대지 않음

### 인터페이스에 새 규칙을 추가하는 방법: default 사용

- 미리 구현한 메서드 추가 = 기존 클래스에 영향을 주지 않음

- 기존 규칙을 구현하면서 새 규칙도 추가로 구현할 수 있음

- 아예 새로 인터페이스를 만들 때는 default 문법을 사용하지 말고 이미 기존의 인터페이스를 구현했을 때는 default 문법을 사용

### 인터페이스에 새 규칙을 추가하는 방법: default 사용의 문제점

- 구현하지 않아도 컴파일 오류가 발생하지 않는 것이 문제 = 메서드 구현을 강제할 수 없음

#### 1) 기존 규칙을 구현하고, 새로 추가한 규칙도 구현

#### 문제점

- 기존 규칙을 상속 받아서 새 규칙을 만들면, 계속 규칙이 늘어나 관리하기가 어려운 문제가 있음
- 규칙에 따라 구분하도록 코딩해야 하기 때문에 프로그래밍 하기가 불편함

#### 2) 기존 인터페이스에 새 메서드를 추가

#### 문제점

- 기존에 구현한 클래스는 모두 오류가 발생할 것

#### Why

- 규칙이 달라졌기 때문에 클래스 구현 오류가 발생하는 것
- 클래스는 항상 인터페이스의 모든 메서드를 구현해야 하기 때문임

#### 해결책

- default 문법을 이용하여  기존 인터페이스에 새 메서드를 추가한다면 이런 문제가 사라짐
- 기존 클래스 입장에서는 구현된 메서드를 상속 받기 때문에 오류가 발생하지 않음

#### 인터페이스의 'default 메서드' 문법의 단점

- 메서드 구현을 강제할 수 없음
- 추상 메서드인 경우, 클래스가 반드시 해당 메서드를 구현해야 함
- default 메서드는 이미 구현했기 때문에 클래스가 다시 구현하지 않아도 컴파일 할 때 문제가 발생하지 않음
- 개발자가 새 기능 구현을 깜박 잊을 수 있다는 것이 문제
- 기존 규칙을 구현하고, 새로 추가한 기능을 구현하지 않아도 컴파일 오류가 발생하지 않음
- 왜? 이미 구현했기 때문임
- 이것이 default 메서드의 문제점임
- 따라서 default 문법은 기존 인터페이스에 새 기능을 추가할 때만 가능한 사용
- 즉 기존에 그 인터페이스에 따라 이미 구현한 클래스들에 영향을 끼치지 않기 위한 용도로만 사용
- 새 인터페이스를 만들 때는 가능한 default 문법을 사용하지 말 것

#### 문제점

- 규칙 즉 인터페이스의 메서드를 변경하거나 제거, 추가하는 순간 이 인터페이스를 구현한 모든 클래스들에서 컴파일 오류가 발생하게 됨

#### 디폴트 메서드(default method)

> JDK8에서 추가한 문법

- 기존 규칙을 변경하되, 기존 구현체(기존 규칙에 따라 작성한 클래스)에는 영향을 끼치고 싶지 않을 때 사용
- 구현할 코드 있으면 작성하고, 없으면 빈 채로 둔다.
- 가능한 일반 클래스의 메서드처럼 사용하지 말 것
- 새 규칙을 추가하는 의미로 default 메서드를 사용해야지, 일반 클래스의 메서드처럼 상속해 줄 목적으로 default 메서드를 만들어서는 안됨

#### default 메서드의 단점

- 인터페이스에 선언하는 메서드는 기본이 추상 메서드이기 때문에 그 인터페이스를 구현하는 클래스는 반드시 해당 메서드를 정의해야 함
- 메서드 정의를 강제하는 것
- 그러나 default 메서드는 이미 구현되어 있기 때문에 클래스에서 반드시 정의할 필요는 없음
- 즉 강제로 정의하게 만들 수 없는 것이 문제임
- 그래서 default 메서드의 용도는 기존에 정의된 인터페이스에 새 규칙을 추가할 때 기존 프로젝트에 영향을 끼치지 않기 위함
- 따라서 새 인터페이스를 정의할 때는 default의 사용을 자제해야 함

#### 3) 기존 규칙에 새 규칙을 추가

- 기존의 규칙을 손대지 않고 새 프로젝트에서 사용할 규칙을 추가하기 위해 기존 인터페이스를 상속 받아서 새 규칙을 추가

#### 문제점

- 문제는 기존에 진행한 모든 프로젝트들과 호환되지 않음

### 인터페이스 활용 : default 메서드의 활용

#### 상속을 이용하여 규칙을 추가할 때

- 서브 인터페이스를 통해 새 규칙을 추가
- 새 인터페이스에 맞는 메서드를 따로 정의해야 함

#### 새 규칙을 추가할 때

- 기존 인터페이스를 계속 사용할 수 있음

### 인터페이스의 활용

- 사용할 도구를 구체적으로 지정(클래스 이름을 사용)하는 대신에 좀 더 추상적인 방식으로 클래스 이름 대신 인터페이스를 사용하여 특정 규칙에 따라 만든 도구를 사용하겠다고 지정
- 이 방식의 장점은 규칙에 따라 만든 도구가 어떤 클래스를 상속 받는 상관하지 X
- 따라서 클래스를 사용하는 것 보다 인터페이스를 사용하는 것이 훨씬 유연한 코딩을 가능하게 함

### 인터페이스 활용: 스태틱 메서드의 활용

> 인터페이스에서 스태틱 메서드는 보통 그 인터페이스를 구현한 객체를 다루는 일을 함

- 수퍼 클래스가 인터페이스를 구현하면 서브 클래스도 구현한 것으로 간주
- 클래스에 선언된 스태틱 메서드와 인터페이스에 선언된 스태틱 메서드는 차이가 있음
- 인터페이스에 선언된 스태틱 메서드는 범위가 더 작음
- 인터페이스에 선언된 구현체를 다루는 용도로 스태틱 메서드를 정의

#### Why

- 구현 메서드를 상속 받았기 때문임

#### 인터페이스 스태틱 활용

- 그 인터페이스의 구현체를 다룰 때 사용

#### 클래스 스태틱 활용

- 클래스의 객체를 다룰 때 사용

#### 정리

- 수퍼 클래스에서 메서드를 구현한 경우 상속 받는 하위 클래스도 구현한 것으로 간주
- 인터페이스에서 스태틱 메서드는 보통 그 인터페이스를 구현한 객체를 다루는 일을 함
- 인터페이스, 즉 규칙을 다루는 스태틱 메서드가 필요한 경우 인터페이스에 스태틱 메서드를 생성

### 인터페이스 구현

#### Adapter 디자인 패턴

> Adapter 객체 = 중간에서 중계하는 역할

- 이 방식을 사용하면 기존 객체를 버리지 않고 새 규칙에 맞춰 재사용 가능

#### 중요

- 기존 인터페이스에 새 메서드를 추가하는 건 기존의 생성한 인터페이스에 영향을 주기 때문에 새 규칙에 따른 메서드를 호출
- 새 인터페이스에 맞춰 기존 객체를 사용하면 새 규칙에 따라 활용

#### 인터페이스 존재 이유

> 규칙을 강제적으로 따르게 하는 것

- 구현을 강제하는 대신 편리성을 제공한 것임

### 디폴트 메서드 - 기존 코드에 영향을 미치지 않고 새 규칙을 추가하는 방법

- 일반적으로 선언하는 인터페이스의 메서드는 public abstract
- 인터페이스를 구현하는 모든 클래스는 반드시 이 메서드를 정의해야 함
- 새 기능을 무심코 추가한다면 기존에 이 인터페이스에 규칙에 따라 작성한 모든 클래스들에 컴파일 오류가 발생
- 새 규칙이 추가되었으면 기존 클래스들도 새 규칙을 구현해야 함
- 기존 인터페이스를 변경하는 것은 매우 위험도가 높음

#### Why

- 새 규칙(메서드)이 추가되었기 때문임

#### default 문법 단점

- 구현할 클래스에게 메서드 구현을 강제할 수 없음

## :pushpin: Day 35

### 인터페이스 구현

> 인터페이스 = 객체 사용법

#### Concrete

> 추상 클래스가 아닌 경우 사용하기 위해 만든 것

- **온전한 객체**를 상속받아 사용하면 **기능 확장**의 의미를 가짐

#### Abstract

> 추상 클래스는 다른 사람 쓰라고 만든 것 (물론 본인도 사용)

- **미완의 객체**를 상속받아 **미완의 기능을 완성**

### 오버라이딩

1. 완성된 메서드를 하위 클래스에서 재정의하는 것
2. 추상 메서드를 하위 클래스에서 완성하는 것

### 추상 클래스 활용 - 서브 클래스를 위해 미리 인터페이스의 일부 메서드를 구현하는 역할

- 서브 클래스를 위해 인터페이스의 일부 메서드를 구현하는 용도로 추상 클래스를 많이 사용
- 추상 클래스의 특성 상 필드와 구현 메서드를 가질 수 있어서 이러한 용도로 많이 사용
  - 인터페이스를 완전하게 구현하지 않았고, 직접 사용할 일도 없기 때문에 더더욱 추상 클래스로 선언해야 함
  - 클래스의 이름이 보통 Abstract로 시작
- 서브 클래스에서 동일하게 구현할 메서드라면 수퍼 클래스에서 미리 구현하여 상속
- 서브 클래스에서 자신의 특성에 맞춰서 구현해야 하는 것이기 때문에 수퍼 클래스에서는 구현하지 X

### 추상 클래스를 상속 받아서 간접적으로 인터페이스를 구현

- 인터페이스를 직접 구현하면 인터페이스에 선언된 모든 메서드를 정의해야 하지만, 미리 인터페이스의 일부를 구현한 추상 클래스를 상속 받으면 좀 더 쉽게 인터페이스를 구현 가능
- 인터페이스의 기본 규칙은 이미 구현했기 때문에 추상 클래스에서 구현하지 않은 메서드만 서브 클래스에서 구현하면 됨

#### 인터페이스를 구현한 조상을 갖는 클래스

- 해당 인터페이스를 구현한 것과 같다.
- 조상으로부터 인터페이스에 선언된 모든 메서드를 상속 받았기 때문임

### 인터페이스 사용: caller를 만드는 입장

#### 인터페이스를 기준으로 한 개발자 입장

- 인터페이스 호출 규칙에 따라 객체를 사용

### 인터페이스 사용: callee를 만드는 입장

#### 인터페이스를 기준으로 한 개발자 입장

- 메서드가 사용할 필터 객체를 만드는 입장
- 개발자는 인터페이스 규칙 따라 클래스를 작성

### Top Level Class

> 패키지에 소속된 클래스 = 패키지 멤버 클래스

#### 접근 범위

- 같은 패키지의 클래스를 사용할 때는 패키지명을 생략 가능
- import도 할 필요가 X

#### 종류

- **public**: 다른 패키지에서도 접근 가능
- **(default) = package-private**: 다른 패키지 접근 불가

### Nested Class

- 특정 클래스 안에서만 사용되는 클래스가 있다면 중첩 클래스로 선언
  - 노출 범위를 좁히는 것이 유지보수에 좋음

#### 종류

1. **static nested class**

- 바깥 클래스의 인스턴스에 종속되지 않는 클래스
- top level class 와 동일하게 사용

2. **non-static nested class = inner class**

- 바깥 클래스의 인스턴스에 종속되는 클래스
  - 중첩 클래스에서 바깥 클래스의 인스턴스 멤버를 사용한다는 뜻
  - 바깥 클래스의 인스턴스 없이 작업할 수 없는 경우 중첩 클래스를 non-static nested class 로 정의
- 바깥 클래스의 인스턴스 없이 생성 불가

3. **local class**

- 특정 메서드 안에서만 사용되는 클래스

#### 접근 제어

- 중첩 클래스도 클래스의 멤버이기 때문에 필드나 메서드처럼 접근 제한자를 붙일 수 있음

#### 로컬 클래스의 접근 제어

- 로컬 변수처럼 로컬 클래스에는 접근 제어 modifier를 붙일 수 X

### static nested class 사용

#### 레퍼런스 선언

```
바깥클래스.중첩클래스 변수명;
```

#### 객체 생성 (인스턴스)

```
변수명 = new 바깥클래스.중첩클래스();
```

#### 선언할 수 있는 멤버

- top level class 처럼 스태틱 멤버 선언 가능
- top level class 처럼 인스턴스 멤버 선언 가능

#### 다른 멤버에 접근하기

- 같은 멤버의 메서드는 클래스 이름을 생략 가능
- 스태틱 멤버는 this라는 빌트인 변수가 없기 때문에 인스턴스 멤버에 접근 불가
- 일반적으로 클래스의 스태틱 멤버(필드,메서드)에 접근할 때는 그 클래스의 이름을 명시해야 함

#### 다른 멤버가 중첩 클래스 사용하기

- 같은 스태틱 멤버는 사용 가능
- 인스턴스 멤버는 스태틱 멤버 사용 가능

#### import static 사용 후

- 스태틱 멤버를 import하기
- 중첩 클래스를 import할 때는 static을 적지 X

#### 같은 패키지 클래스의 스태틱 멤버

- import static 으로 미리 스태틱 멤버의 패키지 정보를 알려주면, 마치 같은 클래스의 멤버인양 클래스 이름 없이 사용할 수 있음
- 각각의 스태틱 멤버를 지정하는 대신 wildcard(\*)를 사용하여 전체 스태틱 멤버를 한 번에 지정할 수 있음

### nested 클래스에서 바깥 클래스의 멤버 사용

- 바깥 클래스의 이름 생략 가능
- 다른 스태틱 메서드처럼 스태틱 중첩 클래스도 인스턴스 멤버 사용 불가

### 인터페이스 구현

#### 호출 규칙에 따라 메서드를 정의

> 인터페이스를 구현한다는 것은 인터페이스에 선언된 모든 메서드를 구현한다는 뜻

#### 한 개라도 빠트리면 추상메서드를 갖고 있는 상태가 됨

- 인터페이스에 선언된 메서드를 한 개라도 빠트리면 추상 메서드인채로 남아 있기 때문에 일반 클래스가 될 수 없고, 추상 클래스가 되어야 함

#### 직접 인터페이스를 구현하기 보다 추상 클래스를 상속 받음

- 인터페이스를 직접 구현하면 인터페이스에 선언된 모든 메서드를 구현해야 하지만, 미리 인터페이스의 몇몇 메서드를 구현한 추상클래스를 상속 받는다면 서브 클래스는 좀 더 쉽게 인터페이스를 구현 가능

**장점**

- 인터페이스에 선언된 메서드 중에서 추상 클래스가 구현하지 않은 메서드만 정의하면 됨
- 매우 편리

**결론**

- 인터페이스의 메서드가 많을 경우 일부 메서드를 미리 구현함으로써 개발자가 좀 더 쉽게 인터페이스를 구현할 수 있게 도와주는 용도로 **추상 클래스 문법**을 사용 가능

#### 추상 클래스를 이용하여 인터페이스 구현을 도와줄 수 있음

- 개발자가 인터페이스를 구현하기 편하도록 서브 클래스에서 오버라이딩할 메서드를 제외한 나머지 메서드를 추상 클래스에서 구현
- 추상 클래스에서 특정 메서드를 제외한 나머지 메서드를 구현
  - 이 추상 클래스를 상속 받는 서브 클래스에서는 단 한 개의 메서드만 구현하면 됨

### 템플릿 메서드

#### 템플릿 메서드를 구현한 클래스 사용

> 기본 적인 실행 흐름은 정의하고 구체적인 행위는 서브 클래스에게 위임하는 설계 기법

- 아직 구체적으로 어떤 명령을 실행할 지 정의되지 않은 상태
  - 틀만 갖춘 상태
- 추상 메서드를 사용하여 템플릿 메서드를 선언

### 디자인 패턴과 추상 클래스

> 수퍼 클래스에서 추상적으로 표현하고, 서브 클래스에서 그 구체적인 내용을 결정하는 설계 방식

- ex) 추상 클래스와 추상 메서드 문법을 이용하여 템플릿 역할을 할 클래스를 정의하는 예

- 수퍼 클래스에서 전체적인 논리 흐름을 정의하고, 서브 클래스에서 각 흐름에 따라 구체적인 동작을 정의
- 일반 메서드에서 전체적인 논리 흐름(명령어 처리의 흐름)을 정의
- 서브 클래스들은 메서드를 그대로 상속 받기 때문에 재정의하지 않는 이상 모든 서브 클래스들이 동일한 방식으로 작업

### non-static nested class

> 인스턴스 없이 사용할 수 없는 멤버

- inner class = instance member
- 레퍼런스 변수 선언은 스태틱 중첩 클래스의 레퍼런스 선언하는 방식과 같음

### 인스턴스 멤버 사용

- new 명령을 실행했을 때 인스턴스 변수를 만들라는 명령

### inner 클래스와 인스턴스 주소

- 바깥 클래스의 인스턴스 주소를 저장할 변수가 자동으로 추가
- 바깥 클래스의 인스턴스 주소를 파라미터로 받아 자동으로 생성한 필드에 보관시키는 생성자가 자동으로 추가
- 컴파일러는 컴파일할 때 자동 생성된 생성자를 호출하도록 코드를 변경

### Inner Class

#### 클래스 정의와 인스턴스 생성

**컴파일러 -컴파일-> inner 클래스**

- 바깥 클래스의 인스턴스 주소를 저장할 필드를 추가
- 바깥 인스턴스의 주소를 받는 파라미터로 받는 생성자를 생성

**인스턴스 생성**

1. 바깥 클래스의 인스턴스 준비
2. 바깥 클래스의 인스턴스 주소를 사용하여 inner class의 인스턴스 생성

**컴파일러 -컴파일-> inner 클래스의 객체를 만드는 코드**

- 바깥 클래스의 객체를 생성자에 전달하는 코드로 변경

#### 선언할 수 있는 멤버

- inner class 는 스태틱 멤버를 가질 수 X
- 스태틱 멤버는 오직 top level class 나 static nested class 만이 가질 수 있음
- 바깥 클래스의 인스턴스를 먼저 만든 다음에 inner 클래스의 인스턴스를 생성

#### 바깥 클래스의 스태틱 멤버에 접근하기

- 바깥 객체없이 중첩 객체 생성 불가
- 중첩 클래스가 인스턴스면 바깥 클래스의 인스턴스 필드를 사용하겠다는 의미
- 바깥 클래스든 패키지 멤버 클래스든 스태틱 멤버를 사용할 때는 클래스 이름으로 해당 멤버를 사용
- 중첩 클래스에서 바깥 클래스의 스태틱 멤버에 접근할 때는 바깥 클래스 이름을 생략할 수 있어 편리

**Why**

- 중첩 클래스도 바깥 클래스의 멤버이기 때문에 같은 멤버의 접근할 때는 클래스명을 생략 가능

#### 바깥 클래스의 인스턴스 멤버 접근하기

- 바깥 객체의 인스턴스 멤버에 접근하려면, inner 객체에 보관된 바깥 객체 주소를 사용해야 함
- 컴파일러가 내부적으로 자동 생성한 바깥 객체 주소를 담는 필드를 사용해야 함
- 문제는 컴파일러가 자동 생성한 필드 이름을 알 수 없음
- 자바는 inner 객체에 보관된 바깥 객체를 가리키기 위해 문법을 제공

```
바깥클래스명.this
```

- 위의 문법을 이용하여 바깥 객체에 접근 가능
- inner 객체를 만들 때 사용한 바깥 객체에 접근하고 싶다면 this 문법을 사용

**컴파일러가 변수를 찾을 때 순서**

- 로컬 변수 -> 인스턴스 변수 -> 바깥 객체의 인스턴스 변수
- 컴파일러는 변수를 찾은 후에 해당 변수의 문법에 맞게 코드를 변경

## :pushpin: Day 36

### inner class

#### 다른 멤버가 중첩 클래스 사용하기

- 스태틱 멤버는 인스턴스 멤버를 사용 불가
- 레퍼런스 선언 가능
- 인스턴스 생성 불가능

##### 이유

- 인스턴스 멤버를 사용하려면 인스턴스 주소가 있어야 함
- 스태틱 메서드는 인스턴스 주소를 담고 있는 this 변수가 존재하지 X

#### import 사용

- 중첩 클래스를 직접 import 가능
  - import 가 하는 일은 클래스를 로딩하는 것이 X
  - 컴파일러에게 클래스의 위치를 알려주는 것

#### 바깥 클래스의 인스턴스를 보관할 this 변수와 생성자

> 인스턴스 메서드는 this 라는 내장 변수에 인스턴스 주소를 보관

##### inner class 보관

- 자바 컴파일러는 바깥 클래스의 인스턴스 주소를 저장하기 위해 필드를 추가
- 컴파일 완료된 inner class의 .class 파일을 열어 보면, 바깥 클래스의 객체 주소를 저장할 인스턴스 필드가 추가된 것을 확인 가능
- 바깥 클래스의 인스턴스 주소를 저장하고 있는 변수를 사용하려면 코드를 작성해야 함

  ```
  [문법] 바깥클래스명.this
  ```

- 인스턴스 메서드에 있는 this 변수는 인스턴스 메서드를 호출할 때 객체 주소를 저장

##### inner class에서 바깥 클래스의 인스턴스 주소 저장

- 바깥 클래스의 인스턴스를 가지고 inner class의 인스턴스를 생성할 때 저장
- inner class의 생성자를 호출할 때 바깥 클래스의 인스턴스 주소를 파라미터로 전달
- 이를 위해 컴파일러는 inner class를 컴파일 할 때 생성자를 변형

```
// 개발자가 기본 생성자를 작성했다고 가정
public X() {}

// 컴파일러가 아래와 같이 변경
public X(E outer) {}
```

##### 컴파일한 .class 파일 생성자

- 바깥 클래스의 인스턴스 주소를 받는 파라미터가 존재
- 컴파일러가 바깥 클래스의 인스턴스 주소를 저장하기 위해 추가한 this$0 라는 변수 확인 가능
- this$0 변수에 바깥 클래스의 인스턴스 주소가 들어 있는 arg0 값을 저장
- 생성자의 파라미터로 받은 바깥 클래스의 객체 주소는 컴파일러가 추가한 인스턴스 필드에 보관

#### 바깥 클래스의 인스턴스를 보관할 this 변수와 생성자 II

> 컴파일러는 모든 생성자에 바깥 클래스의 객체 주소를 받는 파라미터를 추가

##### 중첩 클래스의 인스턴스를 생성

- 컴파일러는 바깥 클래스의 객체 주소를 생성자의 첫 번째 파라미터로 전달
- 컴파일러가 만든 생성자를 호출하도록 코드를 변환

#### inner 클래스에서 변수를 찾는 순서

1. 중첩 클래스의 메서드에서 필드를 사용
2. inner 클래스의 인스턴스 필드 접근
3. 로컬 변수 접근

#### inner 클래스에서 변수를 찾는 순서 II

##### this 명시 X -> 변수 찾는 순서

1. 로컬 변수
2. 메서드가 소속된 클래스의 인스턴스 필드
3. 바깥 클래스의 인스턴스나 스태틱 필드

#### 응용 I : 1단계 - 스태틱 중첩 클래스 사용

- 스태틱 중첩 클래스가 사용할 객체를 넘기기 위해 개발자가 직접 해당 생성자를 호출해 줘야 함
- 스태틱 중첩 클래스에서 바깥 클래스의 인스턴스를 사용하려면 바깥 클래스의 인스턴스 주소를 저장하는 변수를 개발자가 직접 선언해줘야 함
- 바깥 클래스의 인스턴스 주소를 받는 파라미터를 개발자가 직접 생성자에 선언해줘야 함

#### 응용 I : 2단계 - 논스태틱 중첩 클래스(inner class) 사용

- 스태틱 중첩 클래스가 사용할 바깥 클래스 객체를 넘길 때는 파라미터가 아니라 생성자 호출 문장 앞쪽에 놓음
- 중첩 클래스가 바깥 클래스의 객체를 사용해야 한다면, 스태틱 중첩 클래스로 만들지 말고 논스태틱 중첩 클래스(inner class)로 생성

##### Why

- 바깥 클래스의 인스턴스를 저장할 필드가 자동 생성
- 생성자에 바깥 클래스의 인스턴스를 받는 파라미터가 자동으로 추가

1. 논스태틱 중첩 클래스는 바깥 클래스의 인스턴스 주소를 저장할 필드가 자동으로 추가되기 때문에 다음과 같이 개발자가 따로 선언할 필요가 X
2. 바깥 클래스의 인스턴스를 받는 파라미터가 생성자에 자동으로 추가되기 때문에 바깥 클래스의 객체를 받는 파라미터를 개발자가 직접 선언할 필요가 없다.

- 바깥 클래스의 객체 주소를 인스턴스 필드에 저장하는 코드를 작성할 필요가 X
- 내부에 보관된 바깥 클래스의 객체를 사용하고 싶다면, `바깥클래스명.this.멤버` 형식으로 접근

#### 응용 I : 리팩토링

- 바깥 클래스의 인스턴스를 사용하는 inner 클래스라면 inner 클래스의 객체를 만드는 역할도 바깥 클래스가 하는게 유지보수에 더 나음
  - GRASP 설계 기법에서 "정보를 가진 자가 그 일을 하라.(Information Expert)"를 적용
- inner 클래스의 객체를 생성하는 역할을 바깥 클래스가 담당
- 바깥 클래스의 객체 주소 생략

#### 응용 II : inner 클래스와 인터페이스

- 바깥 클래스의 객체 주소 생략
- 인터페이스 구현체를 inner 클래스로 정의

### local class

#### 클래스 정의와 인스턴스 생성

> local class = 메서드 안에 정의하는 클래스

- 특정 메서드 안에서만 사용되는 경우 로컬 클래스로 정의
- 쓸데없이 외부로 노출하지 않기 위함
- 노출을 줄이면 유지보수에 좋음
- 로컬 클래스에서 로컬 이라는 말은 '이 메서드 안에서만 사용할 수 있다'는 뜻
- 사용 범위에 대한 제한을 가리키는 뜻
- 메서드를 호출할 때 클래스가 정의된다는 뜻이 X

#### 사용 범위

- 다른 메서드에 정의된 클래스는 사용 불가

#### .class 파일명

##### 로컬 클래스의 .class 파일명

```
[바깥클래스명]$[정의된순서][로컬클래스명].class
```

#### 인스턴스 메서드와 로컬 클래스

- 인스턴스 메서드는 인스턴스 주소를 this 변수에 저장
  - 인스턴스 메서드 안에 정의된 로컬 클래스는 바깥 클래스의 인스턴스를 사용 가능
- .class 파일을 확인해보면 바깥 클래스에 인스턴스 주소를 저장하는 필드가 선언되어 있음
- 생성자에도 바깥 클래스의 인스턴스 주소를 받는 파라미터가 선언되어 있음

#### 스태틱 메서드와 로컬 클래스

- 스태틱 메서드는 인스턴스 주소를 저장할 this 라는 변수가 X
  - 바깥 클래스의 인스턴스를 사용 불가
- .class 파일을 확인해보면 바깥 클래스의 인스턴스를 보관할 필드가 선언되어 있지 X
- 생성자에도 바깥 클래스의 인스턴스를 받는 파라미터가 선언되어 있지 X

#### 바깥 메서드의 로컬 변수 접근

##### 로컬 클래스 -> 바깥 메서드의 로컬 변수 값 사용

1. 컴파일 할 때 그 값을 저장할 필드를 자동으로 추가

- 사용하는 변수에 대해서만 필드를 생성

2. 로컬 클래스의 객체를 생성할 때 그 값을 사용할 수 있도록 생성자에 파라미터를 추가

- 로컬 클래스에서는 바깥 메서드의 로컬 변수를 자기것인양 사용 가능
- 스태틱 메서드의 로컬 클래스도 인스턴스 메서드의 로컬 클래스와 동일
- 단, 스태틱이기 때문에 바깥 클래스의 인스턴스 주소를 받는 필드는 자동으로 생성되지 X

#### 바깥 메서드의 로컬 변수 접근 I

- 바깥 메서드의 로컬 변수를 사용할 때는 자신의 메서드인양 사용하면 됨

#### 바깥 메서드의 로컬 변수 접근 II

##### this 생략 -> 변수 찾는 순서

1. 로컬 변수
2. 인스턴스 변수
3. 메서드에 선언된 로컬 변수
4. 바깥 클래스의 인스턴스 변수 또는 스태틱 변수

#### 메서드에 선언된 로컬 변수 접근하기

> 로컬 클래스에서는 바깥 메서드의 로컬 변수를 사용 가능

1. final 로 선언된 경우
2. final 로 선언된 것은 아니지만 값을 한 번만 할당한 경우

- 값을 여러 번 할당한 경우에는 접근 불가

##### 결론

- 상수 값이거나 상수에 준하는 경우 (값을 한 번만 할당한 경우) 로컬 클래스에서 메서드의 로컬 변수를 사용 가능
- 로컬 클래스에서 바깥 메서드의 로컬 변수를 사용할 경우에는 값을 조회하는 용도로 사용하는 것

##### Why

- 로컬 클래스의 객체가 사용하는 로컬 변수는 메서드 호출이 끝났을 때 제거되기 때문임

### anonymous class

#### 인터페이스를 구현한 익명 클래스 정의

- 인터페이스의 경우 static으로 선언하지 않아도 스태틱 멤버에서 사용 가능
- 인터페이스는 규칙을 정의한 것이기 때문에 인스턴스 멤버라는 개념이 존재하지 X

1. 로컬 클래스로 인터페이스 구현
2. 익명 클래스로 인터페이스 구현

- 인스턴스를 한 번만 생성할 것이라면, 로컬 클래스로 정의하는 것 보다 익명 클래스로 정의하는 것이 더 나음
- 특히 객체를 사용하려는 곳에 바로 익명 클래스를 정의하면 읽기 쉽기 때문에 소스 코드를 유지보수 하기가 더 좋음

##### 익명 클래스로 인터페이스 구현하기

**문법**

```
인터페이스명 레퍼런스 = new 인터페이스명() {};
```

- 호출하는 생성자는 수퍼 클래스의 생성자

##### 익명 클래스를 정의하는 과정

1. 로컬 클래스
2. 클래스의 이름 삭제

- 클래스의 이름이 없기 때문에 인스턴스를 생성 불가

3. 클래스 이름이 없기 때문에 'class', 'implements' 키워드 삭제
4. 클래스 이름이 없기 때문에 따로 인스턴스를 생성 불가

- 바로 생성해야 함
- 인터페이스 이름 바로 앞에 'new' 키워드를 둠

5. 익명 클래스의 생성자가 없기 때문에 수퍼 클래스의 생성자를 호출

- 객체 생성할 때 항상 생성자를 호출해야 하는데, 클래스에 이름이 없으면 생성자 생성 불가
- 호출할 익명 클래스의 생성자가 X (실제는 내부에 익명 클래스의 기본 생성자 생성)
- 수퍼 클래스의 생성자를 호출해야 함
- 자바의 모든 클래스는 따로 수퍼 클래스를 지정하지 않으면 java.lang.Object 클래스가 수퍼 클래스로 자동 설정
- Object 클래스의 생성자를 호출하도록 지정해야 함
- Object 클래스의 생성자는 기본 생성자 하나 뿐임
- 인터페이스 이름 뒤에 기본 생성자를 호출하는 괄호를 추가

6. 익명 클래스의 레퍼런스 선언

- 익명 클래스는 이름이 없기 때문에 익명 클래스로 레퍼런스를 선언 불가
- 익명 클래스가 구현한 인터페이스나 상속 받는 수퍼 클래스로 레퍼런스를 선언해야 함

#### 클래스를 상속 받은 익명 클래스 정의

> 클래스는 static과 non-static으로 구분

1. 로컬 클래스로 서브 클래스 생성
2. 익명 클래스로 서브 클래스 생성

- 인스턴스를 한 번만 생성할 것이라면, 로컬 클래스로 정의하는 것 보다 익명 클래스로 정의하는 것이 더 나음
- 객체를 사용하려는 곳에 바로 익명 클래스를 정의하면 읽기 쉽기 때문에 소스 코드를 유지보수에 더 좋음

##### 익명 클래스로 인터페이스 구현하기

**문법**

```
수퍼클래스 레퍼런스 = new 수퍼클래스() {};
```

- 호출하는 생성자는 수퍼 클래스의 생성자

#### 수퍼 클래스와 인터페이스를 동시에 지정할 수 있을까?

##### 클래스도 상속 받고 인터페이스도 구현하는 익명 클래스 생성 가능 여부

- 안됨
- 둘 중 하나만 상속 받거나 구현해야지, 동시에 다 할 수 없음

#### 여러 개의 인터페이스를 구현할 수 있을까?

- 안됨
- 익명 클래스에 그런 문법 존재 X

#### 생성자

1. 익명 클래스는 생성자를 직접 정의 불가

- 컴파일러가 컴파일할 때 익명 클래스의 생성자를 생성

2. 대신 인스턴스 블록으로 생성자를 대신함

- 인스턴스 블록에 작성한 코드는 결국 컴파일러가 자동 생성한 생성자에 들어감
- 인스턴스 블록에 작성한 코드가 실행

##### 수퍼 클래스 생성자 호출

- 모든 클래스의 생성자는 항상 수퍼 클래스의 생성자를 먼저 호출
- 인터페이스를 구현한 익명 클래스는 java.lang.Object 클래스를 상속 받음
- 익명 클래스의 생성자는 Object 클래스의 생성자를 먼저 호출

#### 생성자 II

1. 익명 클래스는 생성자를 직접 정의 불가

- 컴파일러가 컴파일할 때 익명 클래스의 생성자를 생성

2. 대신 인스턴스 블록으로 생성자를 대신함

- 인스턴스 블록에 작성한 코드는 결국 컴파일러가 자동 생성한 생성자에 들어감
- 인스턴스 블록에 작성한 코드가 실행

3. 물론 그 전에 먼저 수퍼 클래스의 생성자가 실행

##### 수퍼 클래스 생성자 호출

- 모든 클래스의 생성자는 항상 수퍼 클래스의 생성자를 먼저 호출

#### 호출할 수퍼 클래스의 생성자 지정하기

> 익명 클래스를 정의할 때 호출할 수퍼 클래스의 생성자를 지정 가능

##### 문법

```
new 수퍼클래스명(파라미터,...) {}
```

- 생성자에 넘겨주는 파라미터로 호출될 생성자를 지정

1. 수퍼 클래스의 기본 생성자 호출
2. 수퍼 클래스의 다른 생성자 호출

- 익명 클래스의 인스턴스를 만들 때 값을 지정하면 그 타입의 값을 받는 수퍼 클래스의 생성자가 호출
- 물론 해당 타입의 값을 받을 생성자가 없으면 컴파일 오류가 발생

#### 익명 클래스가 놓이는 장소

##### 스태틱 필드

- 인터페이스의 경우 static으로 선언하지 않아도 스태틱 멤버에서 사용 가능
- 스태틱 필드의 값을 준비할 때 익명 클래스를 사용 가능

##### 인스턴스 필드

- 인터페이스의 경우 static으로 선언하지 않아도 스태틱 멤버에서 사용 가능
- 인스턴스 필드의 값을 준비할 때 익명 클래스를 사용 가능

##### 로컬 클래스

- 인터페이스의 경우 static으로 선언하지 않아도 스태틱 멤버에서 사용 가능
- 로컬 변수의 값을 준비할 때 익명 클래스를 사용 가능

##### 파라미터

> 인터페이스의 경우 static으로 선언하지 않아도 스태틱 멤버에서 사용 가능

1. 로컬 클래스 생성
2. 익명 클래스 생성
3. 익명 클래스를 파라미터 자리에 바로 삽입

## :pushpin: Day 37

### 방법론 (methodology)

> 어떤 사항에 대해 이론이나 경험적 사실을 정리하고 표준화한 것

- 이론
- 경험적 사실
- ex) 레시피
- -> 정리 -> 표준화 (작업 항목, 순서, 산출물, 참여자)

#### 표준화

> 사람이나 조직에 상관없이 경험의 많고 적음에 상관없이 일관된 수준의 결과물을 산출

### 소프트웨어 개발 방법론

> 소프트웨어를 생산 -> 프로그래밍 개발 과정을 정리 -> 개발 과정을 표준화 -> 개인이나 조직에 상관없이 일관성 있는 개발을 유지하고 협업을 잘 수행할 수 있게 돕는 것 -> 양질의 S/W 개발

- ex) 앱, 서비스

#### Example

1. 폭포수 모델

- 분석, 설계, 구현, 테스트

2. 프로토타이핑
3. 반복적, 점진적 개발 (RUP)
4. 애자일 방법론 (Extreme Scrum)

### 요구 사항 식별 방법론

1. 액터 식별

#### actor

- 시스템을 사용하는 사람 또는 프로세스 (S/W), 장치 (H/W)

#### 주 액터 (primary actor)

- 시스템을 사용하는 액터

#### 보조 액터 (secondary actor)

시스템이 사용하는 다른 시스템

- ex) 은행 고객 (primary actor) -> ATM 시스템 -> 씨티은행 시스템 (secondary actor)

### Actor의 관계: 상속

- 액터를 역할에 따라 분류
- ex) PMS (프로젝트 관리 시스템)

### 액터의 관계

- ex) 멘탈 케어

#### 비회원

#### 회원

- 일반
- 의사

### use-case 식별

> 액터가 시스템을 통해 달성하려는 업무 목표

- 유스케이스명 -> 업무명으로 이름을 작성
- 한글 - 명사구
- 영어 - 동사구
  - 관사/전치사를 생략하는 경우가 존재
- ex) 액터 -> 시스템 (유스케이스)

#### 유스케이스 예

- ex) 은행 고객 -> ATM (예금 출금/입금/조회/계좌 이체)

### use-case 식별 가이드

#### 개발 기간 (2주 ~ 4주)

- 개발 관리가 쉬운 크기로 요구 사항 분리 가능
- 보통 use-case 단위로 개발을 관리
- 너무 큰 요구 사항은 관리가 어려움
- 너무 크기가 작은 요구 사항은 관리가 번거로움

1. 한 사람이 한 순간에 수행하는 업무인가?
2. use case의 시작과 끝이 명확한가? 그래서 카운트를 할 수 있는가?
3. 시스템을 통해 처리하는 업무인가?

### use-case 병합

> 여러 use-case를 한 개의 유스케이스로 합치기

#### 이유

- 합치는 게 관리하기 더 쉬울 때

1. CRUD (Creat, Read, Update, Delete) 유스케이스의 경우
2. 서로 밀접하게 관련된 업무인 경우

#### 주의

- 병합한 use-case가 적절한 개발 기간 안에 구현할 수 있는 규모여야 함
  - 개발 관리가 쉬운 방향으로 병합

### use-case 분리

1. 여러 use-case에서 공통으로 수행하는 작업인 경우

- 분리를 통해 식별한 use-case는 업무가 아닌 경우가 존재
- 여러 use-case에서 공통으로 수행해야 하는 작업을 이렇게 분리하면 개발 관리가 쉬워짐

## :pushpin: Day 38

### use-case 관계: 포함과 확장

1. 포함 관계 (include)

> 필수 작업

2. 확장 관계 (extend)

### PMS 시스템: use-cases 모델

#### PMS

#### 비회원

- 회원 가입
- 프로젝트 조회

#### 회원

- 로그인
- 로그아웃
- 프로젝트 참여
- 프로젝트 생성
- 회원 탈퇴

#### 팀원

- 프로젝트 상세조회
- 프로젝트 탈퇴
- 작업 상태 변경
- 작업 조회

#### 팀장

- 프로젝트 변경
- 프로젝트 삭제
- 작업 추가
- 작업 변경
- 작업 삭제

### PMS 시스템: use-case 모델

#### PMS

#### 비회원

- 회원 가입
- 프로젝트 목록 조회

### 추상 클래스 적용

> 중간에서 추상 클래스가 인터페이스의 일부 메서드를 미리 구현해주면 서브 클래스를 만들 때 편리

- 서브 클래스에게 필드와 메서드를 물려줌

### 스택 구현과 사용

> Last In First Out (LIFO)

- ex) 웹 브라우저에 방문 사이트의 URL을 보관할 때

## :pushpin: Day 39

### 리팩토링 - 클래스 이동

> 유지 보수가 쉽도록 클래스의 구조를 변경하는 작업

### 제네릭 적용 전 상황

#### 이점

1. 모든 객체를 추가 가능
2. 어떤 타입의 객체든 리턴 가능

#### 문제점

1. 특정 객체만 추가하도록 제한 불가
2. 특정 타입의 객체만 리턴하도록 제한 불가
3. 매번 리턴 값을 원래 타입으로 형변환 해야 함

- 형변환 하기 번거로움

### 제네릭 적용

#### 타입 파라미터

> 타입 정보를 받는 변수

### 제네릭 문법

- T <- Type
- E <- Element
- V <- Value
- K <- Key
- N <- Number
- S, U, V 등

### 제네릭 문법 적용

- 제네릭을 사용하면 더 정교하게 코드를 사용 가능
- 잘못된 사용을 빠르게 바로 잡을 수 있음
- 제네릭 타입의 배열은 생성 불가

### toArray()

> 넘어온 값이 배열 크기보다 작다면 새 배열을 생성

### Usecase Model: 액터 다이어그램

#### Model

> 생각한 바를 글과 그림으로 표현한 것

#### Modeling

> Model을 만드는 작업

## :pushpin: Day 40

### Generic

> 리턴 타입 = 리턴 타입을 받는 타입

#### 불일치

- 컴파일 오류

#### 해결책

- 형 변환

### 형 변환의 불편 해소

#### 장점

- 코드 중복 해소

#### 단점

- 각각 형 변환해야 함

### 객체 생성 방법

1. new
2. static 메서드 호출 -> 간접 생성

- 복잡한 파라미터 값이 요구될 때 -> 캡슐화

## :pushpin: Day 41

### Lambda 문법 - functional interface의 자격

- 추상 메서드가 한 개짜리 인터페이스여야 함
- 추상 메서드를 한 개만 갖고 있는 인터페이스에 대해 람다 문법으로 익명 클래스를 생성 가능
- 추상 메서드가 두 개 이상이면 람다 문법으로 구현 불가
- 추상 메서드가 두 개 이상인 경우 람다 문법을 사용 불가

#### target type

> 대상으로 하는 타입 (= 인터페이스 타입)

- 여러 개의 메서드가 있다 하더라도 추상 메서드가 한 개이면 가능
- static 메서드나 default 메서드가 몇개이든 그 개수는 중요하지 X
- 추상 메서드가 한 개이면 람다 문법을 사용 가능
- 인터페이스가 아닌 추상 클래스는 람다 구현의 대상이 X

### 메서드 레퍼런스 - 스태틱 메서드 레퍼런스

#### 메서드 한 개짜리 인터페이스의 구현체를 생성

1. 익명 클래스 활용
2. 람바 문법 활용
3. 기존에 작성한 클래스의 스태틱 메서드를 재활용하기

- 인터페이스의 메서드 규격과 일치하는 메서드가 있다면, 그 메서드를 람다 구현체로 사용 가능
- 새로 코드를 작성할 필요가 없어 매우 편리
- 규격
  - 메서드의 파라미터 타입 및 개수, 리턴 타입
- 문법

  ```
  클래스명::메서드명
  ```

#### 리턴 타입

**OK**

- int => double
- int => float
- int => void
  - 메서드의 리턴 값은 무시
- int => Object - plus()가 리턴한 int 값이 오토박싱
  **컴파일 오류**
- int => short
- int => String

#### 메서드 레퍼런스를 지정할 때 리턴 타입의 규칙

1. 같은 리턴 타입
2. 암시적 형변환 가능한 타입
3. auto-boxing 가능한 타입
4. void

#### 결론

- 메서드 레퍼런스가 가리키는 실제 메서드를 호출한 후 그 메서드가 리턴한 값이 인터페이스에 정의된 메서드의 리턴 값으로 사용할 수 있다면 문제가 X

### 파라미터 타입

**OK**

- byte, byte => int, int
- short, short => int, int
- Integer, Integer => int, int - 오토언박싱
  **컴파일 오류**
- long, long => int, int
- float, float => int, int
- Object, Object => int, int
- String, String => int, int
- int => int, int
  - int 값 한 개만 받음 -> int 값 두 개를 요구
- int, int, int => int, int
  - int 값 세 개를 받음 -> 세 개 모두 전달
  - int 파라미터가 두 개만 존재

#### 메서드 레퍼런스를 지정할 때 파라미터 타입 규칙

- 인터페이스 규칙에 따라 받은 값을 실제 메서드에 그대로 전달할 수 있다면 가능

### 메서드 레퍼런스 - 스태틱 메서드 레퍼런스 구현 원리

#### 스태틱 메서드 레퍼런스로 Calculator 구현체를 만드는 방법

**기존 메서드가 메서드 레퍼런스로 전달 가능한지의 여부**

- 인터페이스에 정의된 메서드가 호출되었을 때, 그 파라미터 값은 메서드 레퍼런스로 지정된 스태틱 메서드에게 전달
  - 스태틱 메서드의 파라미터는 항상 인터페이스 메서드에 정의된 파라미터 값을 받을 수 있어야 함
- 스태틱 메서드의 리턴 값은 인터페이스 메서드에 정의된 대로 리턴할 수 있어야 함
  - 스태틱 메서드의 리턴 타입은 인터페이스 메서드의 리턴 타입과 일치하거나 그 타입으로 바꿀 수 있어야 함

### 목록 조회: java.util.Collection의 forEach() 사용법

#### Array

- Interable 객체
  - ex) 동물
- Collection 객체
  - ex) 포유류
- List 객체
  - ex) 유인원

#### iterator

> 목록에서 값을 꺼내주는 자

#### forEach()

> 각각에 대하여 작업을 수행하라

### 메서드 레퍼런스 - 인스턴스 메서드 레퍼런스

> 메서드 한 개짜리 인터페이스의 구현체를 만들 때 기존 인스턴스 메서드를 람다 구현체로 사용 가능

- 단 인터페이스에 선언된 메서드의 규격과 일치해야 함
- 보통 특정 인스턴스 값을 가지고 작업해야 할 경우에 이 방식을 사용
- 규격
  - 파라미터 타입 및 개수, 리턴 타입
- 문법

  ```
  인스턴스::메서드명
  ```

- 인스턴스 메서드를 메서드 레퍼런스로 지정

### 메서드 레퍼런스 - 인스턴스 메서드 레퍼런스 구현 원리

#### 인스턴스 메서드 레퍼런스로 Calculator 구현체를 만드는 방법

1. 람다 표현
2. 익명 클래스
   - 인스턴스 메서드 레퍼런스는 실제 인터페이스 구현체에서 메서드로 호출

### 메서드 레퍼런스 - 활용 예

#### Predicate<String> 인터페이스 구현체 준비

1. 로컬 클래스로 인터페이스 구현체 만들기
2. 익명 클래스로 인터페이스 구현체 만들기
3. 람다로 인터페이스 구현체 만들기
4. 메서드 레퍼런스를 사용하여 기존 클래스의 메서드를 인터페이스 구현체로 사용하기

### 메서드 레퍼런스 - 생성자 레퍼런스

- 인터페이스에 정의된 메서드가 생성자의 형식과 일치하다면 메서드 레퍼런스로 생성자를 지정 가능

1. 익명 클래스로 인터페이스 구현
2. 람다 문법으로 인터페이스 구현
3. 메서드 레퍼런스로 인터페이스 구현

- 인터페이스의 메서드를 호출하면 지정된 클래스의 인스턴스를 만든 후 생성자를 호출

### 메서드 레퍼런스 - 생성자 레퍼런스 구현 원리

- 생성자 레퍼런스를 지정하는 것은 익명 클래스를 만드는 것과 동일

### 메서드 레퍼런스 - 생성자 레퍼런스

- 생성자 레퍼런스를 지정할 때, 인터페이스 메서드의 파라미터에 따라 호출할 생성자가 결정
- 컴파일러는 기본 생성자를 호출하는 Factory 구현체를 만들어 리턴
- 컴파일러는 생성자 중에서 String을 파라미터 받는 생성자를 호출하는 Factory 구현체를 만들어 리턴
- 컴파일러는 생성자 중에서 String과 int를 파라미터 받는 생성자를 호출하는 Factory 구현체를 만들어야 하는데, 클래스에는 String과 int를 파라미터로 받는 생성자가 없기 때문에 Factory 구현체를 생성 불가
  - 컴파일 오류가 발생

### 인터페이스 구현체를 만드는 다양한 방법

1. 로컬 클래스로 인터페이스 구현체를 생성
2. 익명 클래스로 인터페이스 구현체를 생성
3. 람다로 인터페이스 구현체를 생성
4. 기존에 존재하는 메서드를 인터페이스 구현체로 사용
5. 기존 클래스의 생성자를 인터페이스 구현체로 사용

## :pushpin: Day 42

### LinkedList 사용법

#### ArrayList vs LinkedList

**1. 메모리**

**ArrayList**

- 고정 크기를 가짐
- 크기를 초과하면 새로 배열을 만들어야 하기 때문에 메모리 낭비가 심함
- 기존 배열은 가비지가 되기 때문에 가비지가 과다 생산됨

**LinkedList**

- 값을 넣을 때마다 새 메모리가 추가되는 가변 크기를 가짐
- ArrayList 보다 메모리 낭비가 적고 가비지를 덜 생산함

**2. 속도**

**ArrayList**

- 배열의 특징 상 인덱스를 이용하여 특정 항목을 찾을 때 속도 빠름
- 삭제할 때 이전 항목을 당겨와야 하기 때문에 속도가 느림
- 삽입할 때 현재 항목을 다음 항목으로 이동해야 하기 때문에 속도가 느림

**LinkedList**

- 인덱스를 이용하여 특정 항목을 찾을 때 리스트의 처음부터 찾아야 하기 때문에 속도가 느림
- 삭제할 때 이전 항목과 다음 항목을 바로 연결하면 되기 때문에 속도가 빠름
- 삽입할 때 현재항목과 다음 항목을 새 항목과 연결하면 되기 때문에 속도가 빠름

### Stack 클래스 사용법

- push() - 스택의 맨 마지막에 값을 추가
- 타입 파라미터에 전달한 타입과 일치하지 않으면 오류
- pop() - 스택의 맨 마지막에 입력된 값부터 꺼냄
  - 스택은 LIFO(Last In First Out) 방식으로 데이터를 다룸
- 값이 없는데 꺼내려 하면 EmptyStackException 예외가 발생

#### empty()

- push() - 스택의 맨 마지막에 값을 추가

#### peek()

- push() - 스택의 맨 마지막에 값을 추가
- peek() - 맨 위의 값을 꺼냄
  - 단 pop()과는 달리 제거하지 X

#### search()

- push() - 스택의 맨 마지막에 값을 추가
- search() - 스택의 맨 위에서부터 해당 값을 찾음
  - 위치는 맨 위가 1

#### size()

- push() - 스택의 맨 마지막에 값을 추가

#### Iterator 사용

- push() - 스택의 맨 마지막에 값을 추가
- Stack도 Iterable 구현체이기 때문에 for( : ) 문을 사용 가능
  - 내부적으로는 iterator()를 호출하여 Iterator를 얻는 후에 이 Iterator를 통해서 값을 꺼냄
  - 개발자가 직접 Iterator를 사용할 것인지, 아니면 for(:) 문을 통해 간접적으로 처리할 것인지 선택하면 됨

#### 스택과 Deque

**Deque 인터페이스**

- "Double ended queue"의 약자
- 앞, 뒤 모두 양방향에서 값을 넣고 꺼낼 수 있음
- 큐, 스택 둘 다 사용할 수 있도록 queue와 stack 사용법을 모두 정의한 인터페이스
- Dequeue 구현체 중의 하나

### Stack의 Iterator와 Deque의 Iterator 차이점

> Stack 클래스와는 다르게 Deque 구현체의 Iterator는 스택 방식(LIFO)으로 데이터를 꺼냄

**결론**

- Iterator 를 통해 데이터를 꺼낼 때 스택의 특성을 그대로 유지하고 싶다면, Stack 클래스 대신 ArrayDeque 클래스를 사용

**Iterator 설계 기법의 목적**

- 데이터 조회 방식(LIFO, FIFO)에 상관없이 일관된 방법으로 데이터를 조회할 수 있게 도와줌
- 스택처럼 입력 역순으로 꺼내든, 큐처럼 입력 순으로 꺼내든 상관없이 개발자는 hasNext(), next() 라는 동일한 메서드를 사용하여 데이터를 조회함

### Deque의 Iterator 와 for(:) 문

- Iterator 를 통해 데이터를 조회하고 싶다면, for(:) 문을 사용하는 것이 더 나음

## :pushpin: Day 43

### HashSet

- ex) 코로나 백신예약 -> 주민번호 뒷자리
- 해시 값을 가지고 저장할 방의 위치를 결정
- 이미 hashCode(), equals()의 결과 값이 같은 객체가 있기 때문에 중복 저장 X

### ArrayList와 HashSet

### ArratList

> 한 줄에 매달기

#### 위치 정보

- 인덱스
- ex) O-O-O-O-O

### HashSet

> 여러 줄에 매달기

#### 위치 정보

- 해시 값
- ex) O-O-O-O-O O-O-O-O-O

### 객체

- 자바에서 객체를 생성 후 저장하는 문법은 X
- 객체를 리턴 불가
- 주고 받는 건 객체 주소지, 객체 자체가 X

### HashMap

> 기존 주소를 잃어버리면 가비지

#### 같은 Key인지 비교할 때

- hashCode()의 리턴 값
- equals()의 리턴 값

#### Key 사용

> 주로 사용

- int
- String

### Key

- HashCode 값이 다르면 Key 값이 다름
- 인스턴스 주소가 달라도 값이 같으면 Key 값이 같음
- 오버라이딩 하지 않으면 값이 같아도 Key 값이 다름

### java.util.Hashtable - value 목록 꺼내기

#### `hasMoreElements()`

- 꺼낼 값 있냐

#### `nextElement()`

- 꺼내줘

## :pushpin: Day 44

### Github

- 메모리 릭 = 메모리 부족

#### Fork

- 프로젝트 다 끝나고 각자의 repo로 가져감

#### Branch

1. pull과 push를 자유롭게
2. 개발자가 직접 main 브랜치에 병합
3. 책임자는 변경 사항 검토 후 main 브랜치에 병합

- 브랜치를 나눠 개개인의 코드를 브랜치에 올린 후 책임자가 검토를 끝내면 main 브랜치로 병합 => 새 버전

### Git Staging

#### Staged Changes

- 무대 위

#### 사진 찍기

- Commit

#### >

- 한번이라도 커밋

#### ?

- 커밋 후 변동 사항

## :pushpin: Day 45

### 예외 처리 문법을 적용하기 전

#### 리턴 값을 확인하여 오류 여부를 파악하기

- 유효하지 않은 연산자를 지정할 때 제대로 계산을 수행했는지 검사하기 위해서 보통 리턴 값을 검사

#### 리턴 값으로 오류 여부를 알릴 때의 문제점

- 리턴 값을 검사하여 오류 여부를 파악하는 방식은 문제가 발생
- 정상적인 계산 결과도 오류로 취급할 수 있다는 점
- 정상적인 값임에도 불구하고 -1을 리턴하는 경우 오류로 간주하기 때문에 잘못된 결과를 출력

#### 오류일 때 리턴하는 값은 희귀한 값으로 지정

- -1은 일반적인 계산으로 나올 수 있는 흔한 값
- 흔한 값 대신에 일반적인 계산결과로 잘 나오지 않는 값을 지정

#### 리턴 값으로 오류를 알릴 때의 문제를 극복

- 예전에는 작업 실행중에 오류가 발생하면 희귀한 값을 리턴하여 알림
- 일반적인 결과는 정상적으로 수행
- 아무리 희귀한 값을 리턴한다 하더라도 결국에는 그 희귀한 값 또한 정상 값
- 결국 리턴 값을 검사하여 오류 여부를 처리하는 것으로는 이런 문제를 해결 불가
- 리턴 값으로 작업 오류를 알려주는 방식의 한계를 극복하기 위해 만든 문법이 "예외처리" 문법
  - 예외 상황이 발생했을 때 호출자에게 예외 정보를 던져주는 문법

#### 예외 발생 시 시스템 멈춤 문제

- 일반적인 예외의 경우 리턴 값을 검사하여 처리
- 문제는 0으로 나누는 경우에서 처럼 계산할 수 없는 예외 상황이 발생한 경우, JVM은 실행을 종료
  - 0으로 나눌 때처럼 예외가 발생하더라도 JVM을 멈추지 않고 계속 정상적으로 실행되게 만드는 문법이 "예외처리"

### 예외 처리 문법을 적용한 후

#### 오류일 때 예외 정보를 별도로 호출자에게 전달

- 유효하지 않은 연산자인 경우 throw 명령을 이용하여 호출자에게 오류 상황을 알림

#### 메서드가 던지는 예외 정보를 받음

- 리턴 값으로 예외 상황을 알리는 것이 아니라, 예외 정보를 던지는 방식으로 호출자에게 알림
- 예외를 던질 수도 있는 메서드를 호출할 때는 try 블록 안에서 호출
- try 블록 안에서 메서드를 호출하다가 예외가 발생하면 catch 블록에서 파라미터로 받음

#### 시스템을 멈추지 않고 계속 실행 가능

- 입력이 잘못되었을 경우, 나머지 입력을 무시

## :pushpin: Day 46

### 게시판 로그인 정보 활용

1. **Inheritance** (상속)

- ex) 빵 <- 소보루빵

2. **Association** (연관)

- ex) 사람 -> 핸드폰

3. Dependency (의존)

- ex) 학생 - - -> 강사

4. **Aggregation** (집합)

- ex) 컴퓨터 <>-> 마우스
- Lifecycle !=

5. Composition (합성) = 강렬함

- ex) 컴퓨터 <·>-> 메인 보드
- Lifecycle =

## :pushpin: Day 47

### Command 디자인 패턴 적용

#### BoardHandler

- 새 메뉴 추가 -call-> 새 메서드 추가
- 문제점: 새 기능을 추가할 떄 기존 코드를 손댐 = 버그가 생길 가능성을 높임

#### BoardHandler =메서드를 객체화=>

- BoardAddHandler
- BoardListHandler
- BoardDetailHandler
- BoardUpdateHandler
- BoardDeleteHandler
- 새 메뉴를 처리할 클래스

#### 기존 -> 개선

- 만약, 하나의 명령 체제를 하나의 메서드가 담당하고 있다면 메서드를 객체화 시키기 딱 좋은 조건
- => 메서드 객체화 -> 유지 보수 하기가 더 쉬운 구조가 됨 (기존 코드를 손대지 않아도 됨)
- 클래스를 추가하는 것이 기존 코드를 손대는 것보다 이점이 훨씬 큼

#### 메서드를 객체화?

- 메서드를 별도의 클래스로 분리 =설계 기법=> 'Command' 디자인 패턴

#### <<interface>> Command

- execute() <- - -
  - BoardAddHandler
  - BoardListHandler
  - BoardDetailHandler
  - BoardUpdateHandler
  - BoardDeleteHandler
  - 새 메뉴를 처리할 클래스
- 명령을 처리하는 클래스는 Command 규칙에 따라 작성

- 게시글 삭제한다고 게시글 번호가 앞당겨지지 X
- ex) 주민번호 => 죽었다고 당겨지지 X

#### 일반화 적용

- 메서드 공개 범위 디폴트 = private
- ex) 처음 본 사람에게 예민한 정보 비공개

### 리팩토링

- ProjectAddHandler
- ProjectUpdateHandler
- TaskAddHandler
- TaskUpdateHandler

#### <<abstract>> AbstractMemberHandler

> 서브 클래스에 사용하지 않고 외부 클래스에서 사용하는 기능은 수퍼 클래스에 두지 말고 별도의 클래스로 만들어 분리하는 것이 나음

- MemberAddHandler
- MemberListHandler

#### MemberPromptHandler

- promptMember()
- promptMembers()

## :pushpin: Day 48

### Test-Driven Development: TDD

> 톄스트에 의해 주도 당하는

#### 클래스 한 개당 메서드 한 개

- 대가를 치뤄서 기존 코드를 손 대지 않는 상황

### Command 디자인 패턴

- 메서드를 객체화 시킴
- 객체의 사용 규칙 = 메서드 호출 규칙

#### <<interface>> Command

- execute()
  - BoardAddHandler -사용-> List<Board>
  - BoardListHandler -사용-> List<Board>
  - BoardDetailHandler -사용-> List<Board>
  - BoardUpdateHandler -사용-> List<Board>
  - BoardDeleteHandler -사용-> List<Board>
  - 새메뉴를 처리할 클래스 -사용-> List<Board>

### Map으로 객체 관리

#### HashMap

- Key
  - "/board/add"
  - "/board/list"
- Value
  - new BoardAddHandler()
  - new BoardListHandler()

## :pushpin: Day 49

### 로그인 메뉴

- 0001

#### 로그인 전

- 0000

#### 내정보

- 0010

#### 일반 로그인

- 0010

#### 관리자

- 0110

## :pushpin: Day 51

### App 아키텍처 - 지원 기술

> Data I/O Stream API

- 자바 스트리밍 API (java.io.\*)
  - File
  - File InputSteam
  - File OutputSteam

### Data I/O Stream API 주요 클래스

- File -> 파일이나 디렉토리 정보 다룸
- Data, System, Car, Menu, Board, Project
- FileInputStream -> 파일에 데이터 읽어오는 역할
- FileOutputStream -> 파일로 데이터를 출력하는 역할

### 바이너리 파일 VS 텍스트 파일

#### 바이너리 파일

- .pdf, .doc, .xls, .ppt, .gif, .jpg, .mp3, .hwp 등
- 사람이 직접 읽을 수 X
- 전용 App을 사용해야만 읽고 쓸 수 있음

#### 텍스트 파일

- .java, .txt, .md, .html, .css, .js, .c, .rtf, .xml, .docx, .xlsx, .pptx, .properties 등
- 사람이 직접 읽을 수 있다.
- 전용 App 없이 일반 텍스트 에디터로 읽고 쓸 수 있다.

### 바이너리 형식으로 데이터 입출력하기

#### App -> service()

- 파일에서 게시글 가져오기
- **메뉴 실행**
- 파일로 게시글 내보내기

## FileOutputStream

- -write()-> FileOutputStream -> board.data
- write() 메서드는 파라미터로 받은 int 값 중에서 맨 하위 1 byte만 출력

## :pushpin: Day 52

### java.io.File 클래스

#### 폴더 정보 조회

##### File 클래스

- 디렉토리나 파일을 다룰 때 사용하는 클래스
- 파일이나 디렉토리 정보를 관리
- 디렉토리나 파일을 생성, 삭제, 변경 가능

##### 현재 디렉토리를 조회

- '.' 으로 표현
- JVM을 실행하는 위치가 현재 폴더
- 이클립스 : 프로젝트 디렉토리를 가리킴
- 콘솔 : 현재 명령어를 실행하는 위치를 가리킴

##### 상위 폴더 정보 조회

- ".." 으로 경로를 표시

##### 존재하지 않는 폴더 조회

- 존재하지 않는 폴더인 경우 크기는 0
- 존재하지 않는 폴더인 경우 정보를 알아낼 수 X -> 모두 false

#### 파일 정보 조회

##### 현재 파일 정보 조회

- 존재하지 않는 폴더인 경우 크기를 알아낼 수 X
- 존재하지 않는 폴더인 경우 정보를 알아낼 수 X -> 모두 false

##### 존재하지 않는 파일 정보 조회

- 존재하지 않는 폴더인 경우 크기를 알아낼 수 X
- 존재하지 않는 폴더인 경우 정보를 알아낼 수 X -> 모두 false

### 디렉토리 생성

1. 생성할 디렉토리 경로 설정

- 폴더 경로를 지정하지 않으면 현재 폴더를 의미

#### 존재하지 않는 폴더 아래에 새 폴더를 만들 때

- 존재하지 않는 폴더가 자동 생성되지 X
- 따라서 그 하위 폴더를 생성할 수 X
- 디렉토리를 생성할 때 존재하지 않는 중간 디렉토리도 만들고 싶다면, mkdirs()를 호출

#### mkdirs()

- 지정된 경로에 디렉토리가 존재하지 않으면 그 디렉토리도 만듦

### 디렉토리 삭제

- 디렉토리 안에 파일이나 다른 하위 디렉토리가 있다면 삭제 불가
- 또한 존재하지 않는 디렉토리도 삭제 불가

### 파일 생성

#### 생성할 파일의 경로 설정

- 이미 파일이 있다면 다시 생성 불가
- 해당 경로에 디렉토리가 없다면 파일을 생성 불가 -> 예외 발생

#### 존재하지 않는 폴더에 파일을 생성할 때

- 해당 경로에 디렉토리가 없다면 파일을 생성 불가
- 예외 발생

### 파일 삭제

#### 삭제할 파일의 경로 설정

- 존재하지 않는 파일은 삭제 불가
- 경로가 존재하지 않으면 당연히 그 경로에 파일이 없으니까 삭제 불가

### 특정 폴더를 생성하여 그 폴더에 파일을 만듦

#### 생성할 파일의 경로 설정

- 디렉토리가 존재하지 않으면 파일을 생성 불가
- 예외 발생

#### 파일을 생성하기 전에 존재하지 않는 폴더를 생성하고 싶다면,

1. 먼저 디렉토리를 생성
2. 그런 후 파일을 생성

## :pushpin: Day 53

### 프로세스 간 pipe 연결

> 실행 중인 프로그램

- A -Data-> B
  - 파이프를 연결하는 방법
- $ A | B
- ex) $ ipconfig | findstr "검색어" | nano

### 바이트 스트림을 사용해 텍스트 출력하기

- FileOutputStream -출력-> 파일
- ByteArrayOutputStream -출력-> 배열
- PipedOutputStream -출력-> 프로세스
- "AB가각" -getBytes(문자 집합)-> UTF-8: 41 42 EA B0 80 EA B0 81
  - MS949: 41 42 B0 A1 B0 A2
  - UTF-16BE: 0041 0042 AC00 AC01
  - UTF-15LE: 4100 4200 00AC 01AC
- BE형 방식 = 큰 수부터 나옴 ex) UTF
- LE형 방식 = 작은 수부터 나옴

#### `getBytes()`

- file encoding에 따라 영향을 받기 때문에 추천 X
- 파일 인코딩에 의존하지 말고 명확하게 언급할 것

### 자바 I/O 스트림 클래스

- "Data Processing Stream Classes"

> Decorate: 다른 스트림에 연결해서 기능을 덧붙이는 역할

#### byte Stream

- DataInputStream
- DataOutputStream
- ObjectInputStream
- ObjectOutputStream
- BufferedInputStream
- BufferedOutputStream

#### Character Stream

- BufferedReader
- BufferedWriter
- LineNumberReader
- PrintWriter (Sink 스트림에도 포함)

### 바이트 스트림 클래스로 텍스트 파일 읽기

- 텍스트 파일
- UTF-8 -읽기-> FileInputStram -> 바이트 배열 (41 42 EA B0 80 EA B0 81)
- new String(byte[], 문자집합) ⬇️ 변환할 때 file.encoding 환경 변수에 설정된 문자표에 따름
- JVM 문자열 (UTF-16BE) char 타입 -> 0041(A) 0042(B) AC00(가) AC01(각)

> JVM은 문자를 다룰 때 UTF-16BE 문자표를 사용

- new String(byte[], 0, 8) -이클립스에서 실행하면 file.encoding의 값이 UTF-8로 설정 -> new String(byte[], 0, 8, "문자표") -바이트 배열에 들어있는 문자 코드가 어떤 문자들로 인코딩 되었는지 알려주면 제대로 변환 -> 0041 0042 AC00 AC01

## :pushpin: Day 54

### Decorator 패턴 - 기존 기능 확장

> 추가 / 변경 / 삭제가 쉬움

#### 문제점

- 상속을 이용한 기능 확장은 유연성이 부족

### FileOutputStream/FileInputStream

- write(int) -> FileOutputStream -> 파일 -> FileInputStream
- 끝 바이트만 출력
- 리턴 값을 앞에서 부터 채우기 위해 비트 이동 연산자를 사용하여 바이트를 이동
  - int 값은 4번에 걸쳐서 읽어서 비트 이동 연산자를 이용하여 하나의 int 값을 만들어야 함
  - long 값은 4번에 걸쳐서 읽어서 비트 이동 연산자를 이용하여 하나의 long 값을 만들어야 함

### 상속을 이용한 기존 기능 확장

- FileOutputStream <- DataFileOutputStream (writeUTF(String), writeInt(int), writeLong(long))
- 080557d2 <- DataFileOutputStream

## :pushpin: Day 55

### list() -> File

- 파일 생성
- 파일 삭제
- 파일 수정

### <-read()- FileInputStream

> 파일을 읽어들이는 것

- ex) Binary File

### <-write()- FileOutputStream

> 파일을 쓰는 것

- '가'
  1. AC00 **BE**
  2. 00AC **LE**
- 기본 UTF 하면 BE형 방식

### "AB가각" <- FileReader

> 직접 바이트 배열로 변경하는 대신 해줌

- ex) Text File

### "AB가각" <- FileWriter

> 직접 바이트로 변경하는 대신 해줌

### Member

- name: String
- age: int
- gender: boolean

### FileOutputStream

- write(int)
- write(byte[])
- write(byte[])

### ⬆️ DataFileOutputStream

> 데이터를 출력할 수 있도록 가공하는 일

## :pushpin: Day 56

### java.io.Serializable과 serialVersionUID

- 컴파일러가 클래스에 부여하는 버전, 개발자가 임의로 설정 가능
- writeObject(객체 (인스턴스) <- Serializable 구현체만 출력 가능) -> ObjectOutputStream -> 인스턴스 (객체)의 각 필드의 값을 byte[]로 변환 + 클래스 정보 (클래스 버전 정보 ex) 3720) -출력-> -읽기-> ObjectInputStream -deserialize (역직렬화)-> readObject() -생성-> 객체 <- 파일에서 읽어들인 데이터의 클래스 버전과 현재 갖고있는 클래스의 버전이 동일해야 함
  - ex) 3800

### 메타 데이터 - HTML

#### <h1> 자바 프로그래밍 </h1>

- 콘텐트 (Content) = data
- 콘텐트를 설명 = meta data = tag = markup (출판 용어) = element (기술 용어)
- PC 컴퓨터 <-> 센서 장치
- 이기종
  - ex) Windows <-> Linux
- Java App <-> C App
  - 서로 다른 언어/운영체제인 경우 이기종이라 함
  - .gif <- 표준 포맷으로 만든 바이너리 파일을 이기종 간 교환 가능
- 객체 시리얼 데이터 <- 자바 시리얼 데이터는 표준 포맷이 아니기 때문에 이기종 언어간 호환 X <- 읽고 쓸 수 X
- binary 형식으로 출력한 것은 해당 포맷을 알지 못하면 읽고 쓸 수 X => 그에 비해 텍스트 형식은 이기종 간에 읽고 쓸 수 O => 텍스트 형식으로 데이터를 주고 받는 경우가 많음

#### 텍스트 형식

- ex) XML, CSV, JSON 등

### MIME 타입

#### 형식

- Multi-purpose
- Internet
- Mail
- Extensions
  - 인터넷 상에서 데이터를 보내고 받을 때 어떤 형식의 데이터인지 알려주는 이름
  - 국제적으로 표준 포맷이 정의되어 있음

#### 데이터

- 처음에는 전자 우편을 주고 받을 때 데이터 포맷을 알려줄 목적으로 사용 -> 지금은 웹 상에서 데이터를 주고 받을 때에도 사용

#### 타입/서브타입

##### Example

- test/html
- test/css
- test/javascript
- test/csv
- application/pdf
- application/zip
- application/msword

## :pushpin: Day 57

### CSV 문자열을 만드는 일

1. 기존 방식

- Board -가져와서-> App -가공-> CSV 문자열
  - no
  - title
  - content

2. 개선

- Board <-1. CSV 문자열을 요구 `toCsvString()`- App
- -생성-> CSV 문자열
- CSV 문자열을 만드는 책임이 App 클래스에서 데이터를 갖고 있는 Board 클래스로 이동 <- Information Expert

### Project 객체를 CSV 형식으로 출력하기

- 번호, 제목, 내용, 시작일, 종료일, 관리자 번호, 관리자명, 멤버 목록, 작업 목록
- 저장
  - CSV 형식의 한계
  - 즉, 데이터가 다른 데이터를 포함하는 경우 CSV 형식으로 표현하기 어려움
  - =해결=> 계층 구조로 된 데이터를 잘 표현할 수 있는 포맷
    - => XML, JSON

## :pushpin: Day 58

### CsvValue 인터페이스

- List <-3. 저장- loadObjects() {} ↩️ 2. 객체 생성한 후 csv 문자열의 값으로 초기화 <-1. 읽기- csv 파일
- List <-1. 꺼내서- saveObjects() {} ↪️ 2. 객체에서 csv 문자열을 얻어서 (도메인 객체.toCsvString() 호출) -3. 저장-> csv 파일

#### <<interface>> CsvValue

- toCsvString()
- loadCsv()

- 객체를 CSV 형식의 데이터로 읽고 쓰는데 사용할 규칙을 정의
- -> loadObjects() | saveObjects() 메서드를 이 규칙에 따라 객체를 다룸
- 규칙을 정의하는 개발자와 그 규칙을 사용하는 개발자 간의 합을 맞추기 위해 규칙을 정함

### 메타 데이터 - JSON

- 데이터를 설명하는 데이터 콘텐트로 설명 = meta data = markup
- Serialization: JSON으로 만듦
- Deserialization: JSON을 원래 문자열로 되돌림

### Collection

#### <<interface>> Interable

- iterator() <- 목록에서 데이터 꺼내는 기능
- forEach() <- 목록에서 데이터 꺼내는 기능

#### ⬆️ <<interface>> Collection

- add() <- 목록에 데이터를 추가/삭제하는 기능, 검사하는 기능
- remove() <- 목록에 데이터를 추가/삭제하는 기능, 검사하는 기능
- size() <- 목록에 데이터를 추가/삭제하는 기능, 검사하는 기능
- isEmpty() <- 목록에 데이터를 추가/삭제하는 기능, 검사하는 기능
- contains() <- 목록에 데이터를 추가/삭제하는 기능, 검사하는 기능

#### ⬆️ <<interface>> List

- get() <- 목록의 데이터를 인덱스로 다루는 기능
- set() <- 목록의 데이터를 인덱스로 다루는 기능
- indexOf() <- 목록의 데이터를 인덱스로 다루는 기능

#### ⬆️ <<concrete>> ArrayList

- 데이터 조회
- 데이터 추가/삭제/검사
- 인덱스

### 객체 -> JSON 문자열 : 객체의 필드 값을 json 형식의 문자열로 만들기

1. 객체 준비
2. JSON 처리 객체 준비
3. 객체의 값을 JSON 문자열로 얻기

#### JSON 객체 형식 - { 객체 정보 }

```
{ "프로퍼티명" : 값, "프로퍼티명": 값, ...}
```

##### 값:

- 문자열 => "값"
- 숫자   => 값
- 논리   => true, false
- 프로퍼티명은 반드시 문자열로 표현해야 한다.

### 객체 -> JSON 문자열 : 배열 다루기

#### JSON 배열 형식 - [{ 객체 정보 },{ 객체 정보}, ...]

```
[
{"프로퍼티명"*:*값,"프로퍼티명"*:*값, ...},
{"프로퍼티명"*:*값,"프로퍼티명"*:*값, ...},
{"프로퍼티명"*:*값,"프로퍼티명"*:*값, ...},
...
]
```

### 객체 -> JSON 문자열 : 컬렉션 다루기

#### JSON 컬렉션 형식 - [{ 객체 정보 },{ 객체 정보}, ...]

- 배열을 출력한 것과 동일
- JSON은 배열과 컬렉션을 구분하지 X

```
[
{"프로퍼티명"*:*값,"프로퍼티명"*:*값, ...},
{"프로퍼티명"*:*값,"프로퍼티명"*:*값, ...},
{"프로퍼티명"*:*값,"프로퍼티명"*:*값, ...},
...
]
```

### JSON 문자열 -> 객체 : 컬렉션 다루기

1. TypeToken 클래스의 서브 클래스를 생성

- 수퍼 클래스를 지정할 때 제네릭의 타입을 설정
- TypeToken 클래스에는 Type 인터페이스의 구현체를 만드는 메서드가 있기 때문에 이 클래스의 서브 클래스를 만드는 것
- 타입 파라미터에 컬렉션 타입을 전달하는 목적 이외에는 다른 이유가 X
  - 서브 클래스에 뭔가를 추가할 필요가 X

2. TypeToken 객체 준비
3. TypeToken 객체를 통해 Type 구현체를 얻음
4. Type 객체에 저장된 정보를 바탕으로 JSON 문자열로부터 컬렉션 객체를 생성

### 객체 -> JSON 문자열 : 다른 객체를 포함하는 경우

#### 다른 객체를 포함했을 때 JSON 형식

```
{
프로퍼티명 *:* 값,
프로퍼티명 *:* {프로퍼티명*:*값,프로퍼티명*:*값,...},
...
}
```

### 객체 -> JSON 문자열 : 다른 객체를 목록으로 포함하는 경우

#### 다른 객체를 목록으로 포함했을 때 JSON 형식

```
{
프로퍼티명 *:* 값,
프로퍼티명 *:* {프로퍼티명*:*값,프로퍼티명*:*값,...},
프로퍼티명 *:* [{...},{...},{...},...],
...
}
```

## :pushpin: Day 59

### Command 규칙 변경

#### <<interface>> Command

- execute() -> excute(파라미터) <- CommandRequest <- Command 객체를 실행할 때 이 객체에 필요한 값을 담아 전달

### 17-a. 다른 핸들러를 실행할 때 값 넘기기

- 게시글 상세보기 -> App -execute()-> BoardDetailHandler -변경(U) execute()-> BoardUpdateHandler
- 게시글 상세보기 -> App -execute()-> BoardDetailHandler -삭제(D) execute()-> BoardDeleteHandler

### 17-b. 다른 핸들러를 실행할 값 넘기기

- App -execute()->

### 17-c. 커맨드 객체 간의 종속성 없애기

- 게시글 상세보기 -> App -execute()-> BoardDetailHandler
- -변경(u)-> RequestDispatcher -execute()-> BoardUpdateHandler
- RequestDispatcher -execute()-> BoardDeleteHandler

1. 객체 간의 관계를 빠르게 파악하기

#### CommandRequest

> 핸들러에게 값을 전달하는 일 / 핸들러끼리 값을 주고 받는 일

#### RequestDispatcher

> 커맨드의 요청을 받아 대신 실행 / 커맨드리퀘스트를 만드는 일

- 커맨드(핸들러) 객체 간의 종속성이 제거
- BoardDetailHandler
- BoardUpdateHandler
- BoardDeleteHandler

## :pushpin: Day 60

### 17-b. 다른 핸들러를 실행할 때 값 넘기기

#### <<commad>> A -execute()-> <<commad>> B

- 다양한 값을 전달할 수 있도록 특별한 파라미터 '바구니'를 새로 정의

#### commandRequest

- 파라미터 타입을 정의
- command 객체를 실행할 때 이 객체에 필요한 값을 담아 전달
- 서블릿 = command

### 17-c. 커맨드 객체 간의 종속성 없애기

- 의존한다 = 이 클래스 없이 컴파일 불가한 상태
- 엮여있다 -> 커플링

#### 웹 프로그래밍: 서블릿

> 하나의 서블릿에서 다른 서블릿을 사용할 때 execute()를 사용하지 않고 RequestDispatcher를 사용해 처리

- 구조는 더 복잡하지만 command를 직접 리턴하는 방법 보다는 RequestDispatcher를 사용하는게 향후 유지 보수에 더 나음

### 18-a. Observer 디자인 패턴: 옵저버 패턴이 필요한 이유

#### `new Date(System.currentTimeMillis())`

- 1970년 0시 0분 0초 부터 카운트

### 18-b. 'Observer' 패턴으로 구조 변경

- 실행 -> App -호출-> service() (리스너 실행)

### Observer 패턴

- 관찰자 | 감시자 = listener
- 보호 관찰자 <-특정 상태에 대해 전화로 보고-|-상태를 감시-> 가석방 죄수 (보호 관찰자의 전화번호) => Observer = Listener <-2. 보고 (메서드 호출)- 1. 상태 변경 객체 (Observer 객체 주소)

### Observer 디자인 패턴의 클래스 다이어그램

- Observer (m1(), m2()) <-m1(), m2()- Subject (add Listener(Observer), removeLisner(Observer), listeners: List)

1. 특정 상태에 놓이면
2. 규칙에 따라 호출

- 객체가 특정 상태일 때 기능을 추가/삭제 하기가 쉬움

### 18-b. Observer 패턴 적용

- App -call-> <<interface>> ApplicationContentListener (App 시작할 때 -> contextInitialzed(), App 종료할 때 -> contextDestroyed())

#### App <- Subject = Publisher (= 발행자)

- ex) 가석방 죄수
- addApplicationContextListener()
- removeApplicationContextListener()

#### ApplicationContentListener <- Observer = Subscriber (= 수신자)

- ex) 보호 관찰자

#### Observer 목표

- 기능을 언제든 추가하거나 뺄 수 있음
- 객체가 특정 상태에 놓일 때 기능을 추가하고 싶을 때 쉽게 가능하도록 하는 디자인 패턴

### 18-b. 환영 메세지 출력을 옵저버로 처리

#### App

```
service() {
환영 메세지 출력
종료 메세지 출력
}
```

##### <<ApplicationContextListener>> AppInitListener

- contextInitialized() {}
- contextDestroyed() {}

### 18-c. 파일 로딩 및 저장 기능을 옵저버로 처리

- App =옵저버로 분리=> <<ApplicationContextListener>> AppInitListener

### 옵저버 적용

#### App -옵저버로 분리->

##### AppInitListener

- 환영 메세지
- 종료 메세지

##### FileListener

- 파일 로딩
- 파일 저장

### Subject(Publisher)와 Observer(Subscriber = Lister) 간의 값 공유하기

- <<subject>> App -1. call | contextInitialized(), contextDestroyed()-> <<Observer>> FileListener 2. 작업
- Map <-작업 결과 보관 | 조회- <<Observer>> FileListener - - -> <<Observer>> ApplicationContextLister
- 데이터를 저장하고 꺼내기 위해 List 객체 사용

### 19. 파일을 공유하기

1. 현재 애플리케이션 구조의 문제점 (Application Architecture)

#### PC

- 사용자 -실행 (입력/출력)-> App <-로딩-|-저장-> 파일
- 사용자 -실행-> App <-로딩-|-저장-> 파일
- 프로그램끼리 데이터 공유 불가
  - ex) 인사팀 파일 <-> HR <-사원 등록- 직원
- 데이터 공유 X -> 업무 수행 불가
- 직원이 수행한 작업 결과가 각 직원의 PC에 저장 -> 직원 간 작업 결과의 공유가 어려움

### 해결책

1. 컴퓨터 공유
2. 파일을 주고 받기 -> 매우 번거로움 / 동시 작업 불가

### 19. 데이터를 공유하는 고전적인 방법 - 파일 서버 또는 네트워크 드라이브로 파일 공유

- 직원 -사용-> <<PC>> HR <-읽고/쓰기-> <<PC>> 파일 (파일이 들어있는 디렉토리를 공유)
- 네트워크 드라이브로 다른 PC의 디렉토리에 접근

#### 특징

- 같은 파일을 접근하기 때문에 프로그램 간에 파일을 주고 받을 필요가 X
- 여러 App에서 파일을 동시에 접근할 때 다른 프로그램이 데이터를 저장하는 동안 또 다른 프로그램이 파일에 데이터를 저장한다면 다른 프로그램이 작업한 데이터를 덮어쓸 수 있음

### 19. 여러 App에서 같은 파일을 읽고 쓸 때 문제점 해결

- 직원 -사용-> <<PC>> HR -> <<PC>> -데이터 읽고 쓰기 요청-> 파일 관리 App (중간에서 데이터를 덮어쓰지 않도록 파일에 데이터를 읽고 쓰는 것을 관리) <-읽고 쓰기-> 파일

### 프로그램 간의 데이터 교류 => 네트워킹 기술 필요

- App <-응답- 네트워킹 -요청-> 파일 관리 App <-> 파일
- 요청을 받아서 처리해 주는 역할 => "Server"
- 서버에 작업을 요청하는 역할 => "Client"
  - ex) 서버: 카톡 서버
  - 클라이언트: 메신저 <-> 카톡 서버
  - 게임 API <-> 게임 서버 (wow 서버)
  - 메일 App <-> 메일 서버
  - 일정 서버 <-> 파일
  - 캘린더 App <-> 파일 관리 App
  - 웹 브라우저 <-> Web 서버

### 파일의 데이터를 전문적으로 관리 -> DBMS

- 사용자 -> App <-통신 = JDBC API- DBMS <-I/O-> 파일
- 파일에서 데이터를 저장, 로딩
- 파일에서 데이터를 찾기
- 사용자에 따라 접근을 제어
  - ex) Oracle, MS-SQL, DB2, MYSQL, MariaDB, PostareSQL, Tibero, Cubrid, App

## :pushpin: Day 61

### 19 단계의 목표 -> 다인용 Application으로 전환

#### Enterprise Application Architecture

- ~~구조~~ -> Architecture

#### App. Architecture 변경

- 1인용 App -> 19. 다인용 App
- 동시 사용 => 같은 기능을 여러 명이 동시에 작업할 수 있는 App

#### 공동 이용

- 다인용 -> 사용자 -ID/PWD-> App <-> 파일
- 공동 이용 -> ID/PWD로 사용자 구분

#### 목표

- 개인별 이용 -> 동시 사용 = 데이터 공유
- 사용자 -> App <-> 파일
- 동시에 같은 업무를 수행할 수 있는 Application 만들기 -> "기업용 App" => Enterprise App
- 기업용 App -> 동시 작업 -> 데이터 공유 => 무결성 제약 조건 통제 (integrity)
- (Enterprise) =제어=> 트랜잭션 기술 (transaction)
- 동시 작업을 제어하는 방법이 필요

### 19 단계

- PMS -> Client PMS <-입력/결과 출력 => UI 제공-> 사용자 -> Server PMS <-I/O-> 파일
- Client PMS <-결과 응답-데이터 요청-> Server PMS
- 여러 Client가 Server와 데이터 공유를 하도록 하기 위함

## :pushpin: Day 62

### 19-b. 데이터 주고 받기

- ClientApp <-응답-요청-> ServerApp
- 데이터 송수신

### 네트워킹

- 컴퓨터 Lan Card

#### Internet

##### WAN

**Wide Area Network**

- 회사 -Gateway-> Local Area Network
- Network Internet C; 릭 = 로컬 네트워크를 연결하는 카드
- Gateway: 입구와 입구를 열 때

### 네트워킹 - 두 대의 컴퓨터에서 통신

- ClientApp <-> ServerApp
- 컴퓨터 <-> 컴퓨터

### 네트워킹 - 한 대의 컴퓨터에서 통신

- ClientApp ServerApp
- 컴퓨터 NIC
- 통신사 - Gateway - HUB - HUB - 컴퓨터
- 프로그램과 프로그램 사이에 데이터를 직접 주고 받는 방법은 X (두 대의 컴퓨터나 한 대의 컴퓨터나 마찬가지)

### Socket 클래스

- ClientApp -X-> ServerApp
- ⬇️ Socket-> NFC -Socket-> ⬆️
- NIC을 통해 Application 끼리 데이터를 주고 받게 도와주는 역할

### Socket과 ServerSocket

- ClientApp -X-> ServerApp
- ⬇️ Socket-> NFC -ServerSocket-> -Socket-> ⬆️
- 요청하는 쪽 요청받는 쪽

#### Best Practies; BP

- Practies (실천) = 경험
  - ex) Design Pattens -> Refactory (정리 최선의 방법) -> Qusle Sort (정렬 최선의 방법)
- ip Adress: 어느 컴퓨터의 어느 프로그램 주소
- 몇번 포트 프로그램인지 알기 위해 포트 번호가 필요

### 포트 번호

- ClientApp -2700-> ServerApp 1
- ClientApp -3200-> ServerApp 2
- ClientApp -4300-> ServerApp 3
  - 포트 번호 (Port): 통신할 대상을 구분하는 번호
- Client 측, Server 측 모두 Port 번호가 필요

### ServerSocket/Socket과 포트 번호

- 모든 소켓은 포트 번호가 존재
- ClientApp -> Socket 24777 -> ServerApp <- Socket 37411 (내선 번호) <- ServerSocket 3477 (대표 번호)

### 다중 Client와 포트 번호

- ServerSocket 7222 (고정) Application에서 부여
- C1 - Socket 32000 (임의) -> Server 41171 -> S
- C2 - Socket 37180 (임의) -> Server 51130 -> S
- C3 - Socket 36220 (임의) -> Server 52300 -> S
- OS가 임의 값 부여
- 데이터를 주고 받기 위해 소켓이 필요하고 소켓과 소켓을 구분하기 위한 포트 번호가 필요

- ServerSocket 7222 (고정) Application에서 부여
- 탭 1 -링크 클릭-> 요청 -> Socket 32000 (임의) -> Server 41171 -> 웹 서버
- 탭 2 -링크 클릭-> 요청 -> Socket 37180 (임의) -> Server 51130 -> 웹 서버
- 탭 3 -링크 클릭-> 요청 -> Socket 36220 (임의) -> Server 52300 -> 웹 서버
- OS가 임의 값 부여
- 웹 브라우저는 훨씬 더 많은 소켓을 사용하며 소켓이 지정되어야 포트 번호가 부여
  - ex) 개인 간의 연락을 위해 서로의 연락처가 필요한 것처럼 고유의 포트 번호가 존재

#### Server

- HTTP: 80
- ServerSocket은 데이터를 받는 쪽에만 존재

#### 접속 후 데이터 송수신

- Socket <-> Socket
- ⬆️ OutputStream ⬇️ InputStream
- ⬆️ Data (출력) ⬇️ Data (읽기)

#### 접속 후 데이터 송수신 + 데코레이터

- 기존 클래스 손 대지 않고 기능 추가
- Socket <-> Socket
- ⬆️ OutputStream ⬇️ InputStream
- ⬆️ <<Decorator>> PrintWriter ⬆️ BufferedReader
- ⬆️ Data (println() / printf() / print())
- 네트워킹 프로그램은 연결만 되면 종료, 그 후 부터는 입출력 프로그램

#### 네트워킹 입출력

```
/* 메세지를 보내기 위해 반드시 호출할 것
 * 상대편에게 확실히 데이터를 보내고 싶다면 반드시 명시할 것 */
out.flush();
```

- print()를 해준다고 서버에 데이터가 보내지지 X
- 파일 입출력과 개념이 다름 -> 헷갈리지 말 것

### 19-c. 프롬프트 적용

- ClientApp -접속-> ServerApp

1. 접속
2. 프롬프트로 입력 받기
3. 보내기
4. 보낸 데이터 그대로 리턴
5. "quit"
6. "goodbye"
7. 접속 종료

- 클라이언트가 한 줄의 문자열을 보낼 때까지 리턴하지 X

#### readLine() VS println()

```
/* 소켓에서 한 줄의 문자열을 보낼 때까지 기다림
 * 서버에서 한 줄의 문자열을 보낼 때까지 기다림 */
readLine();
```

- 데이터를 보내든 말든 기다리지 않고 출력하는 println()과 달리 readLine()은 서버에서 한 줄의 문자열을 보낼 때까지 기다림
- pms: 데이터 저장 관리

### 19-d. Client와 Server 간 통신 규칙 정의

- protocol 예) FTP, HTTP, Telnet, SMTP, POP3, IMAP 등
- ClientApp -접속-> ServerApp

1. 접속
2. 요청
   1. 명령 한 줄
   2. JSON 데이터 한 줄
3. 응답
   1. 처리 결과 한 줄
   2. JSON 데이터 한 줄

### 19-d. Board 객체 저장 및 조회

#### ClientApp

- Board -new Gson().toJson() | serialize (직렬화)-> {-} JSON -> Socket -> Socket -> JSON 문자열 -new Gson().toJson() | deserialize (역직렬화)-> Board

## :pushpin: Day 63

### 19-e. PMS를 Client/Server로 분리

- Client App <-UI 처리- PMS -데이터 저장 관리-> Server App
- domain 객체
- handler 객체

### 19-e. 통신 기능

> 사용자에게 json으로 바꾸는거 신경 쓰지 않도록 전체 다 캡슐화

#### 캡슐화 ex)

- 핸드폰 내부적으로 어떻게 돌아가는 지 모름

#### Board -request (명령 | 객체)-> RequestAgent -> RequestProcessor

- 프로토콜에 따라 서버에 요청하는 기능을 캡슐화 -> 복잡한 코드를 클래스에 감추는 것 -> 만약 통신 프로토콜이 바뀌더라도 RequestAgent만 변경해도 됨 -> 최소 변경

#### `in.readLine();`

- 무조건 빈 문자열이라도 읽음

### 19-e. 통신 기능 캡슐화

#### RequestProcessor -execute(Request(요청 정보) | Response(응답 처리))-> BoardTable

- 클라이언트 요청을 받아 처리
- 웹은 int 형식이 아닌 문자 형식으로 값을 저장

#### `startsWith()`

- 파라미터 안에 있는 문자처럼 이렇게 시작한다면

#### `response`

- 결과 상태, 결과 값을 저장

#### `readLine()`

- 요청하거나 응답할 때 두 줄의 문자열을 보내는게 규칙

#### `out.flush()`

- 쏜다

### 19-f. 파일 및 데이터 처리 기능을 서버 프로젝트로 이전

#### ~~PMS~~

##### Client

- UI 제공
- 업무 수행

##### Server

- 데이터 저장
- 데이터 관리

- 기존 구조 (Standalone App) -**변경 <= migration (마이그레이션)**-> 새 구조

## :pushpin: Day 64

### 19-f. C/S 연동 구조

#### Client

##### RequestAgent <-응답-요청->

- BoardAddHandler
- BoardListHandler

- UI 제공
- 업무 로직 수행

#### Server

##### RequestProcessor

- BoardTable <-> 파일
- MemberTable <-> 파일

- 데이터 관리
- 데이터를 파일에 보관/로딩

### <<abstract>> DataTable

- 일반화

##### BoardTable

- file name: String
- loadObject()
- saveObject()

##### MemberTable

- file name: String
- loadObject()
- saveObject()

##### 추상 클래스

> 추상 클래스와 인터페이스는 문법의 목적이 다름

- 꼭 물려주고 싶은 메서드가 있다면 사용
  - 일하세요 -요청-> 관리자 -일해-> 쌀밥 먹는 자 <- 사람 -> 고기
  - 누굴 상속 받냐에 상관없이 작업자 규칙에 따라 만든다
    - 일하세요 -요청-> 관리자 -일해-> 작업자 <- 사람

#### `getCLass()`

- 현재 클래스의 정보를 가져옴

#### `getField()`

- 현재 클래스에 있는 필드 중에서 파라미터로 받은 이름을 가진 필드 정보를 가져옴

#### `getType()`

- 일반 클래스

#### `getGenericType()`

- 제네릭 적용된 클래스

## :pushpin: Day 65

#### AbstractTaskHandler =>

- printTasks()
- getStatusLabel()
- promptStatus()
- promptStatue(-)

#### ⬆️ TaskHandlerHelper

- printTasks()
- getStatusLabel()
- promptStatus()
- promptStatue(-)

#### ⬆️ TaskAddHandler | TaskDetailHandler

### 19-g. 다중 클라이언트 접속 처리

1. stateful

- **고객** <-1. 연결, 2. 문의, 3. 답변-> **상담사**

2. stateless

- **고객** <-1. 연결, 2. 인증 요청, 3. 답변, 4. 끊기-> **코로나 인증 전화**, **114 전화 안내**
- 클라이언트가 연결을 끊기 전까지 계속 연결

1. 소수의 클라이언트 요청 처리
2. 서버는 클라이언트 정보를 유지
3. 메모리 많이 사용

- -> 응답 후 즉시 연결을 끊는다

1. 다수의 클라이언트 요청 처리
2. 서버는 클라이언트 정보를 유지하지 않는다
3. 메모리 적게 사용

- 메일 전송 ->
- <- 게임
- 검색 ->
- <- 채팅

### 클라이언트 VS 서버

- 클라이언트는 요청하는 입장
- 서버는 요청을 받아 작업을 요청하는 입장

### 네트워킹

- Connection-Oriented = TCP
  - 연결 후 데이터 송/수신 ex) 전화
  - 데이터 송/수신에 대한 신뢰 보장
    - Stateful 연결 -> 요청 <-> 응답 -> 끊기
    - Stateless 연결 -> 요청 -> 응답 -> 끊기
- Connectionless = UDP
  - 연결 없이 데이터 송/수신 ex) 편지, 택배, 라디오

## :pushpin: Day 66

### 19-i. 멀티 스레드

> 멀티 = 다중 / 스레드 = thread(실) - 실행 흐름 ex) 상담사

1. **기존 방식**

- Client (고객 1~3) -1. 연결-2. 요청- - -> <- - - 응답 ~~-~~ 5. 연결 끊기- Server (상담사) 3. 요청처리
  - 시간이 오래 걸리면 -> 다음 클라이언트의 대기 시간이 길어짐

1. **개선**

- 고객 1 <-> 상담사
- 고객 2 -> 상담사
- 고객 3 - 상담사

> 상담사 수만큼 고객의 요청을 동시에 처리 가능

### JVM과 Thread

- 실행 -> JVM "main" 실행 흐름 main() 호출 ——클라이언트 접속——> 종료
  - 새 실행 흐름 생성 -> 시작
  - run() 호출 —————> 종료
  - run() 호출 ——↕️ 서로 간섭 X——> 종료
  - run() 호출 —————> 종료

### 스레드 정의하기

> "main 실행 흐름"과 별개로 독립적으로 실행할 코드를 정의하기

```
class MyThead extends Thread {
	@Override
	public void run() {
		// 독립적으로 실행할 코드
	}
 }
```

### PMS의 멀티 스레드

- 실행 -> JVM "main" 실행 흐름 main() 호출 -클라이언트 접속-> 종료
- **JVM** main -호출-> main() -Client 접속—요청 처리-

### 18 vs 19 애플리케이션 아키텍처

1. **18** App <-> 파일

- List <-> 메모리
  - BoardAddHandler
  - BoardListHandler
  - BoardDetailHandler

2. **19** Client <-> SeverApp <-> 파일

- RequestAgent <-> 서버
  - BoardAddHandler
  - BoardListHandler
  - BoardDetailHandler

> BoardListHandler 대신 RequestAgent으로 다 뜯어 고침

3. **21** DBMS 도입

- Statement <-> DBMS 서버
  - BoardAddHandler
  - BoardListHandler
  - BoardDetailHandler

## :pushpin: Day 67

### 애플리케이션 아키텍처 변화

#### Board

- no
- title
- content
- registeredDate
- viewCount
- like

#### Member

- no
- name
- email
- password
- photo
- tel
- registeredDate

#### Project

- no
- title
- writer
- startDate
- endDate

#### Task

- tasks

#### Manager

- position
- fas

#### Teacher

- major
- hourPay

### Builder 디자인 패턴

1. 단순 객체 생성

```
new Gson()
```

2. 복잡한 기능을 갖는 객체 생성 -캡슐화; 복잡한 코드를 클래스에 넣어서 감춤 ex) requestAgent->

#### GsonBuilder

```
Gson gson = new Gson();
gson.xxx(); <- 부가 기능 설정
```

### 애플리케이션 아키텍처의 변경 내역

- App -데이터 저장-> 배열
- App -데이터 저장-> Collection
- App -데이터 저장-> Collection <-보관/로딩-> 파일
- ClientApp <-처리 결과 응답-통신-데이터 처리 요청-> ServerApp -데이터 저장-> Collection <-보관/로딩-> 파일

#### DBMS

- ClientApp <-처리 결과 응답-통신-데이터 처리 요청-> DBMS (개발자는 데이터 보관과 조회에 신경 쓸 필요 X)

### DBMS 개요

- Database Mansgement System
- 데이터 보관과 조회를 서비스하는 프로그램

#### Database

- 실시간 접근 가능: 데이터 처리 요청에 즉시 응답
- 동시 공유: 여러 사용자가 공유
- 데이터의 독립성: 애플리케이션에 비종속
- 일관성: 데이터 처리 작업이 끝난 후 데이터의 값은 유효한 상태를 유지 (-> ex) 특정 회원 데이터 삭제 -> 삭제한 회원의 글도 삭제)해야 함
- 무결성: 유효하지 않은 데이터의 등록과 변경, 삭제를 제한 (-> ex) 게시글 작성자를 삭제 불가)
- 보안성: **사용자 인증** ((authentication) ID/PWD 일치 -> 유효한 사용자)**과 권한 검사** ((authentication) 기능의 이용 권한 검사 -> 동적 허용? 변경 허용?)

#### DBMS

- 데이터베이스를 조작하는 S/W
- ex)
  - Oracle
  - MySQL
  - DB2
  - MS-SQL
  - Altibase
  - Tibero
  - Cubrid 등

### SQL

- App -데이터 처리 요청 (요청 명령을 작성하는 문법 -> Structured Query Language) -> DBMS

#### DDL (Data Definition Language)

> 데이터 구조 정의 문법

#### DQL (Data Query Language)

> 데이터 조회 요청 문법

#### DML (Data Management Language)

> 데이터 등록/변경/삭제 문법

- DML = DQL + DML
  - DQL과 DML을 합쳐서 DML이라 칭함

### SQL

- App -표준 SQL 문법 (DBMS에 공통으로 사용할 수 있는 문법)-> DBMS
- App + 오라클 전용 문법 -> Oracle
- App + MySQL 전용 문법 -> MySQL
- App + MS-SQL 전용 문법 -> MS-SQL

### DBMS와 SQL

- **Oracle** 유료
- Sun - **MySQL** 무료/유료
- FaceBook, Google, Apple, Twiter-> **MariaDB** 무료
- MySQL과 MariaDB의 포트 번호가 같아서 동시에 실행 X
  - 포트 번호 변경 후에는 가능

### DBMS와 SQL

- ServerApp | PMS Server <-요청-HTTP-응답-> ClientApp | PMS Client
- Web Server <-요청-HTTP-응답-> Web Browser = HTTP Client

---

- MariaDB (mysqld.exe) <-요청-MariaDB protocol-응답-> MariaDB Client (mysql.exe) <-SQL 입력-결과 출력-> 사용자
  - ex) ServerApp <-> ClientApp <- Prompt

### SQL 테스트 준비

1. 사용자 추가

> create user 'study'@'localhost' identified by '1111'

- ex) [localhost](http://localhost)에서 study 아이디로 접속하는 경우에 허락하겠다는 의미

> create user 'study'@'%' identified by '1111'

2. 데이터를 저장할 데이터베이스 생성

- create database studydb character set utf8 collate utf8_general_ci;

3. 데이터베이스를 사용할 사용자의 권한을 지정

> grant all on studydb.\* to 'study'@'localhost';

### DDL (Data Definition Langage)

1. 테이블 생성

```
crate table test01 (
name varchar(50) not null,
kor int not null,
eng int not null,
math int not null,
sum int not null,
aver float not null);
```

- 엑셀과 비교
  - sheet = table
  - \*.xsl 파일 = database

### 테이블과 row, column

- column = attribute = filend
- row = record = tuple

## :pushpin: Day 68

### DBMS 개요

- <-결과 출력-명령어 (SQL 언어로 명령어 작성)-> DBMS Clinet (MariaDB Client App) <-요청 처리 결과-DBMS 통신 규칙-데이터 작업의 요청-> DBMS (MariaDB) -Data I/O-> 파일

- 데이터를 파일에 저장
- 파일에 저장된 데이터를 조회/변경/삭제
- 데이터베이스의 기능을 제공

### SQL

1. DDL -> 데이터를 저장하고 다룰 DB 객체를 정의

- Table, View, Reocedure, Function

2. DQL -> DB 객체의 데이터를 다룸 ⬆️

- DML -> DB 객체의 데이터를 다룬다 ⬆️

### 테이블

```
create table 테이블명 (컬럼, ...) <- 테이블 정의
drop table 테이블명 <- 테이블 삭제
alter table 테이블명 변경사항 <- 테이블 변경
describle 테이블명 <- 테이블 정보 조회
= desc
```

### insert

```
insert into test1(no, name) values(1, 'aaa')
```

- test1 = 테이블명
- (no, name) = 컬럼명 <- 컬럼을 나열한 순서와 일치해야 함
- (1, 'aaa') = 컬럼에 들어갈 값
- 컬럼의 순서와 일치

### select

```
select no, name from test1
```

- no, name = 컬럼명

```
create table test1(
  no int not null,
  name varchar(20) default 'noname', <- 0 ~ 20자
  age int default 20
);
```

### key, comdidate key, primary key/alternate key

- condidate key = 최소 키
- primary key/alternate key = artificial key

#### key <- 데이터를 구분할 때 사용할 컬럼들

- [이메일] <- Candidate Key (최소 키)
  - 나중에 바꿀 때를 대비
  - 주 키로 선정되지 않은 나머지 후보키는 '대안 키' -> "Alternate Key"
- [아이디] <- Candidate Key (최소 키)
  - DB 관리자가 주 키로 결정한 Key = "Primary Key"
- [주민번호] <- Candidate Key (최소 키)
  - 개인 정보 때문에 잘 적지 않음
  - 주 키로 선정되지 않은 나머지 후보키는 '대안 키' -> "Alternate Key"
- [이름, 전화번호] <- Candidate Key (최소 키)
  - 하나로 구분해도 되기 때문에 굳이 두 개의 값으로 구분할 필요 X
  - 주 키로 선정되지 않은 나머지 후보키는 '대안 키' -> "Alternate Key"
- ~~[아이디, 전화번호]~~
- ~~[이메일, 주민번호]~~
- ~~[이메일, 이름]~~
- ~~[주민번호, 이름]~~
- ~~[이름, 우편번호]~~
- ~~[이름, 아이디, 전화번호]~~

### Artificial Key

- 게시글: 제목, 내용, 작성일, 작성자, 조회수, 좋아요수 |게시글 번호|

#### Primary Key

- 마땅히 사용할 Key가 없을 경우
- -> 임의의 컬럼을 만들어 PK로 지정 = Artificial Key (인공 키)
  - ex) 일련 번호
- PK는 기본으로 not null

### Alternate key

#### constraint; 제약

- 유니크 라는 의미의 UK
- 유니크 컬럼은 not null이라고 설정하지 않는 이상 null 값을 허용
- 처음부터 중복되어선 안되는 값은 유니크 컬럼으로 설정

### View

- 셀렉트 문을 가상으로 테이블로 사용
- 어떤 테이블의 정보가 들어가 있는지는 테이블 마다 다름

### Commit

1. autocommit = true

   - -1. insert-> MariaDB Client -2. 요청 전달-> MariaDB -3. insert-> Test1
   - <-결과 출력- MariaDB Client <-4. 입력 결과- MariaDB -> Test1

2. autocommit = false

   - -1. insert-> MariaDB Client -2. 요청 전달-> MariaDB -> Test1
   - -4. commit/rollback-> -3. 실행 명령 저장-> insert (임시 DB)
   - -5. commit/rollback 요청-> MariaDB -6. 임시 작업을 취소->

- A 회사 <- 결제, 메일, 게시판 G/W
- 트랜잭션 = commit/rollback

## :pushpin: Day 69

### select

- 사용자 ←출력-(SQL → 명령어 → )입력→ MariaDB Client (mysql.exe) ←처리 결과-데이터 처리 요청→ MariaDB Server ←I/O→ 파일

#### DDL

1. 테이블 정의/변경/삭제

#### DML

##### DML

1. 입력/변경/삭제

##### DQL

1. 조회/검색

### selection / projection

- **no, name** ← 특정 컬럼 값만 선택하는 것 = projection
- **working = 'Y'** ← 특정 조건에 해당하는 레코드(row)만 선택하는 것

#### 순서

- from → where → select

```
select *
from test1
where class like 'java%';
```

- %: 0개 이상의 문자가 옴

```
select *
from test1
where class like '%java%';
```

- %java%: java로 시작하는 모든 것

```
select *
from test1
where name like 's0_';
```

- \_: 딱 1자를 의미

### Foreign Key

1.  자바 객체

- Board <>-writer- Member
- Board <>-files- AttachedFile
  - no
  - title
  - content
  - registeredDate
  - viewCount

2.  테이블 간 관계 (ER-Diagram; ERD)

> Entity | Relation

- 객체 간의 관계 → 프로그래밍 하기 쉬운 쪽으로 객체 간의 관계를 설정
- 테이블 간의 관계 → 데이터 중복을 최소화시키는 쪽으로 관계를 설정

- ERD 표기법

1.  Information Engineering Notation

- 공학 → 경험으로 얻은 사실을 학문으로 체계화 시켜서 연구하는 것
  - ⇒ 해당 분야에 종사하는 사람들이 시행착오를 줄이게 도와줌

### Foreign Key (외부 키) - 다른 테이블의 PK 값

- 게시글 (FK) -PK를 가리킴 (참조)→ (PK) 번호
- 작성자 (FK) -PK를 가리킴 (참조)→ (PK) 번호

- 자식 테이블 -참조→ 부모 테이블
- 자식 테이블 → 부모 테이블

- 데이터를 하나 삭제해도 그 데이터와 연결된 모든 데이터를 삭제 ⇒ 무결성
- 일치성과 무결성을 기본으로 제공
- 하나의 데이터가 다른 데이터를 종속

## :pushpin: Day 70

## :pushpin: Day 71

## :pushpin: Day 72

## :pushpin: Day 73
